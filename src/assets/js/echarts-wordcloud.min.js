!(function (t, e) { typeof exports === 'object' && typeof module === 'object' ? module.exports = e(require('echarts')) : typeof define === 'function' && define.amd ? define(['echarts'], e) : typeof exports === 'object' ? exports['echarts-wordcloud'] = e(require('echarts')) : t['echarts-wordcloud'] = e(t.echarts) }(this, function (t) {
 return (function (t) { function e (n) { if (r[n]) return r[n].exports; const i = r[n] = { i: n, l: !1, exports: {} }; return t[n].call(i.exports, i, i.exports, e), i.l = !0, i.exports } var r = {}; return e.m = t, e.c = r, e.d = function (t, r, n) { e.o(t, r) || Object.defineProperty(t, r, { configurable: !1, enumerable: !0, get: n }) }, e.n = function (t) { const r = t && t.__esModule ? function () { return t.default } : function () { return t }; return e.d(r, 'a', r), r }, e.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, e.p = '', e(e.s = 25) }([function (t, e) { function r (t, e) { G[t] = e } function n (t) { if (t == null || typeof t !== 'object') return t; let e = t; const r = W.call(t); if (r === '[object Array]') { e = []; for (var i = 0, a = t.length; i < a; i++)e[i] = n(t[i]) } else if (E[r]) { const o = t.constructor; if (t.constructor.from)e = o.from(t); else { e = new o(t.length); for (var i = 0, a = t.length; i < a; i++)e[i] = n(t[i]) } } else if (!N[r] && !F(t) && !T(t)) { e = {}; for (const s in t)t.hasOwnProperty(s) && (e[s] = n(t[s])) } return e } function i (t, e, r) { if (!S(e) || !S(t)) return r ? n(e) : t; for (const a in e) if (e.hasOwnProperty(a)) { const o = t[a]; const s = e[a]; !S(s) || !S(o) || w(s) || w(o) || T(s) || T(o) || M(s) || M(o) || F(s) || F(o) ? !r && a in t || (t[a] = n(e[a], !0)) : i(o, s, r) } return t } function a (t, e) { for (var r = t[0], n = 1, a = t.length; n < a; n++)r = i(r, t[n], e); return r } function o (t, e) { for (const r in e)e.hasOwnProperty(r) && (t[r] = e[r]); return t } function s (t, e, r) { for (const n in e)e.hasOwnProperty(n) && (r ? e[n] != null : t[n] == null) && (t[n] = e[n]); return t } function l () { return $ || ($ = U().getContext('2d')), $ } function h (t, e) { if (t) { if (t.indexOf) return t.indexOf(e); for (let r = 0, n = t.length; r < n; r++) if (t[r] === e) return r } return -1 } function u (t, e) { function r () {} const n = t.prototype; r.prototype = e.prototype, t.prototype = new r(); for (const i in n)t.prototype[i] = n[i]; t.prototype.constructor = t, t.superClass = e } function c (t, e, r) { t = 'prototype' in t ? t.prototype : t, e = 'prototype' in e ? e.prototype : e, s(t, e, r) } function f (t) { if (t) return typeof t !== 'string' && typeof t.length === 'number' } function d (t, e, r) { if (t && e) if (t.forEach && t.forEach === H)t.forEach(e, r); else if (t.length === +t.length) for (let n = 0, i = t.length; n < i; n++)e.call(r, t[n], n, t); else for (const a in t)t.hasOwnProperty(a) && e.call(r, t[a], a, t) } function v (t, e, r) { if (t && e) { if (t.map && t.map === Y) return t.map(e, r); for (var n = [], i = 0, a = t.length; i < a; i++)n.push(e.call(r, t[i], i, t)); return n } } function g (t, e, r, n) { if (t && e) { if (t.reduce && t.reduce === V) return t.reduce(e, r, n); for (let i = 0, a = t.length; i < a; i++)r = e.call(n, r, t[i], i, t); return r } } function p (t, e, r) { if (t && e) { if (t.filter && t.filter === j) return t.filter(e, r); for (var n = [], i = 0, a = t.length; i < a; i++)e.call(r, t[i], i, t) && n.push(t[i]); return n } } function m (t, e, r) { if (t && e) for (let n = 0, i = t.length; n < i; n++) if (e.call(r, t[n], n, t)) return t[n] } function x (t, e) { const r = X.call(arguments, 2); return function () { return t.apply(e, r.concat(X.call(arguments))) } } function y (t) { const e = X.call(arguments, 1); return function () { return t.apply(this, e.concat(X.call(arguments))) } } function w (t) { return W.call(t) === '[object Array]' } function _ (t) { return typeof t === 'function' } function b (t) { return W.call(t) === '[object String]' } function S (t) { const e = typeof t; return e === 'function' || !!t && e == 'object' } function M (t) { return !!N[W.call(t)] } function T (t) { return typeof t === 'object' && typeof t.nodeType === 'number' && typeof t.ownerDocument === 'object' } function k (t) { return t !== t } function C (t) { for (let e = 0, r = arguments.length; e < r; e++) if (arguments[e] != null) return arguments[e] } function P (t, e) { return t != null ? t : e } function I (t, e, r) { return t != null ? t : e != null ? e : r } function A () { return Function.call.apply(X, arguments) } function O (t) { if (typeof t === 'number') return [t, t, t, t]; const e = t.length; return e === 2 ? [t[0], t[1], t[0], t[1]] : e === 3 ? [t[0], t[1], t[2], t[1]] : t } function D (t, e) { if (!t) throw new Error(e) } function L (t) { t[Z] = !0 } function F (t) { return t[Z] } function R (t) { t && d(t, function (t, e) { this.set(e, t) }, this) } function B (t) { return new R(t) } function z () {} var N = { '[object Function]': 1, '[object RegExp]': 1, '[object Date]': 1, '[object Error]': 1, '[object CanvasGradient]': 1, '[object CanvasPattern]': 1, '[object Image]': 1, '[object Canvas]': 1 }; var E = { '[object Int8Array]': 1, '[object Uint8Array]': 1, '[object Uint8ClampedArray]': 1, '[object Int16Array]': 1, '[object Uint16Array]': 1, '[object Int32Array]': 1, '[object Uint32Array]': 1, '[object Float32Array]': 1, '[object Float64Array]': 1 }; var W = Object.prototype.toString; const q = Array.prototype; var H = q.forEach; var j = q.filter; var X = q.slice; var Y = q.map; var V = q.reduce; var G = {}; var U = function () { return G.createCanvas() }; G.createCanvas = function () { return document.createElement('canvas') }; let $; var Z = '__ec_primitive__'; R.prototype = { constructor: R, get: function (t) { return this['_ec_' + t] }, set: function (t, e) { return this['_ec_' + t] = e, e }, each: function (t, e) { void 0 !== e && (t = x(t, e)); for (const r in this) this.hasOwnProperty(r) && t(this[r], r.slice(4)) }, removeKey: function (t) { delete this['_ec_' + t] } }, e.$override = r, e.clone = n, e.merge = i, e.mergeAll = a, e.extend = o, e.defaults = s, e.createCanvas = U, e.getContext = l, e.indexOf = h, e.inherits = u, e.mixin = c, e.isArrayLike = f, e.each = d, e.map = v, e.reduce = g, e.filter = p, e.find = m, e.bind = x, e.curry = y, e.isArray = w, e.isFunction = _, e.isString = b, e.isObject = S, e.isBuiltInObject = M, e.isDom = T, e.eqNaN = k, e.retrieve = C, e.retrieve2 = P, e.retrieve3 = I, e.slice = A, e.normalizeCssArray = O, e.assert = D, e.setAsPrimitive = L, e.isPrimitive = F, e.createHashMap = B, e.noop = z }, function (t, e, r) { function n (t) { i.call(this, t), this.path = null } var i = r(12); const a = r(0); const o = r(6); const s = r(50); const l = r(56); const h = l.prototype.getCanvasPattern; const u = Math.abs; const c = new o(!0); n.prototype = { constructor: n, type: 'path', __dirtyPath: !0, strokeContainThreshold: 5, brush: function (t, e) { const r = this.style; const n = this.path || c; const i = r.hasStroke(); const a = r.hasFill(); const o = r.fill; const s = r.stroke; const l = a && !!o.colorStops; const u = i && !!s.colorStops; const f = a && !!o.image; const d = i && !!s.image; if (r.bind(t, this, e), this.setTransform(t), this.__dirty) { let v; l && (v = v || this.getBoundingRect(), this._fillGradient = r.getGradient(t, o, v)), u && (v = v || this.getBoundingRect(), this._strokeGradient = r.getGradient(t, s, v)) }l ? t.fillStyle = this._fillGradient : f && (t.fillStyle = h.call(o, t)), u ? t.strokeStyle = this._strokeGradient : d && (t.strokeStyle = h.call(s, t)); const g = r.lineDash; const p = r.lineDashOffset; const m = !!t.setLineDash; const x = this.getGlobalScale(); n.setScale(x[0], x[1]), this.__dirtyPath || g && !m && i ? (n.beginPath(t), g && !m && (n.setLineDash(g), n.setLineDashOffset(p)), this.buildPath(n, this.shape, !1), this.path && (this.__dirtyPath = !1)) : (t.beginPath(), this.path.rebuildPath(t)), a && n.fill(t), g && m && (t.setLineDash(g), t.lineDashOffset = p), i && n.stroke(t), g && m && t.setLineDash([]), this.restoreTransform(t), r.text != null && this.drawRectText(t, this.getBoundingRect()) }, buildPath: function (t, e, r) {}, createPathProxy: function () { this.path = new o() }, getBoundingRect: function () { let t = this._rect; const e = this.style; const r = !t; if (r) { let n = this.path; n || (n = this.path = new o()), this.__dirtyPath && (n.beginPath(), this.buildPath(n, this.shape, !1)), t = n.getBoundingRect() } if (this._rect = t, e.hasStroke()) { const i = this._rectWithStroke || (this._rectWithStroke = t.clone()); if (this.__dirty || r) { i.copy(t); let a = e.lineWidth; const s = e.strokeNoScale ? this.getLineScale() : 1; e.hasFill() || (a = Math.max(a, this.strokeContainThreshold || 4)), s > 1e-10 && (i.width += a / s, i.height += a / s, i.x -= a / s / 2, i.y -= a / s / 2) } return i } return t }, contain: function (t, e) { const r = this.transformCoordToLocal(t, e); const n = this.getBoundingRect(); const i = this.style; if (t = r[0], e = r[1], n.contain(t, e)) { const a = this.path.data; if (i.hasStroke()) { let o = i.lineWidth; const l = i.strokeNoScale ? this.getLineScale() : 1; if (l > 1e-10 && (i.hasFill() || (o = Math.max(o, this.strokeContainThreshold)), s.containStroke(a, o / l, t, e))) return !0 } if (i.hasFill()) return s.contain(a, t, e) } return !1 }, dirty: function (t) { t == null && (t = !0), t && (this.__dirtyPath = t, this._rect = null), this.__dirty = !0, this.__zr && this.__zr.refresh(), this.__clipTarget && this.__clipTarget.dirty() }, animateShape: function (t) { return this.animate('shape', t) }, attrKV: function (t, e) { t === 'shape' ? (this.setShape(e), this.__dirtyPath = !0, this._rect = null) : i.prototype.attrKV.call(this, t, e) }, setShape: function (t, e) { const r = this.shape; if (r) { if (a.isObject(t)) for (const n in t)t.hasOwnProperty(n) && (r[n] = t[n]); else r[t] = e; this.dirty(!0) } return this }, getLineScale: function () { const t = this.transform; return t && u(t[0] - 1) > 1e-10 && u(t[3] - 1) > 1e-10 ? Math.sqrt(u(t[0] * t[3] - t[2] * t[1])) : 1 } }, n.extend = function (t) { const e = function (e) { n.call(this, e), t.style && this.style.extendFrom(t.style, !1); const r = t.shape; if (r) { this.shape = this.shape || {}; const i = this.shape; for (const a in r)!i.hasOwnProperty(a) && r.hasOwnProperty(a) && (i[a] = r[a]) }t.init && t.init.call(this, e) }; a.inherits(e, n); for (const r in t)r !== 'style' && r !== 'shape' && (e.prototype[r] = t[r]); return e }, a.inherits(n, i); const f = n; t.exports = f }, function (t, e) { function r (t, e) { const r = new S(2); return t == null && (t = 0), e == null && (e = 0), r[0] = t, r[1] = e, r } function n (t, e) { return t[0] = e[0], t[1] = e[1], t } function i (t) { const e = new S(2); return e[0] = t[0], e[1] = t[1], e } function a (t, e, r) { return t[0] = e, t[1] = r, t } function o (t, e, r) { return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t } function s (t, e, r, n) { return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t } function l (t, e, r) { return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t } function h (t) { return Math.sqrt(u(t)) } function u (t) { return t[0] * t[0] + t[1] * t[1] } function c (t, e, r) { return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t } function f (t, e, r) { return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t } function d (t, e) { return t[0] * e[0] + t[1] * e[1] } function v (t, e, r) { return t[0] = e[0] * r, t[1] = e[1] * r, t } function g (t, e) { const r = h(e); return r === 0 ? (t[0] = 0, t[1] = 0) : (t[0] = e[0] / r, t[1] = e[1] / r), t } function p (t, e) { return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])) } function m (t, e) { return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]) } function x (t, e) { return t[0] = -e[0], t[1] = -e[1], t } function y (t, e, r, n) { return t[0] = e[0] + n * (r[0] - e[0]), t[1] = e[1] + n * (r[1] - e[1]), t } function w (t, e, r) { const n = e[0]; const i = e[1]; return t[0] = r[0] * n + r[2] * i + r[4], t[1] = r[1] * n + r[3] * i + r[5], t } function _ (t, e, r) { return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t } function b (t, e, r) { return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t } var S = typeof Float32Array === 'undefined' ? Array : Float32Array; const M = h; const T = u; const k = p; const C = m; e.create = r, e.copy = n, e.clone = i, e.set = a, e.add = o, e.scaleAndAdd = s, e.sub = l, e.len = h, e.length = M, e.lenSquare = u, e.lengthSquare = T, e.mul = c, e.div = f, e.dot = d, e.scale = v, e.normalize = g, e.distance = p, e.dist = k, e.distanceSquare = m, e.distSquare = C, e.negate = x, e.lerp = y, e.applyTransform = w, e.min = _, e.max = b }, function (t, e, r) { function n (t, e, r, n) { r < 0 && (t += r, r = -r), n < 0 && (e += n, n = -n), this.x = t, this.y = e, this.width = r, this.height = n } const i = r(2); const a = r(8); const o = i.applyTransform; const s = Math.min; const l = Math.max; n.prototype = { constructor: n, union: function (t) { const e = s(t.x, this.x); const r = s(t.y, this.y); this.width = l(t.x + t.width, this.x + this.width) - e, this.height = l(t.y + t.height, this.y + this.height) - r, this.x = e, this.y = r }, applyTransform: (function () { const t = []; const e = []; const r = []; const n = []; return function (i) { if (i) { t[0] = r[0] = this.x, t[1] = n[1] = this.y, e[0] = n[0] = this.x + this.width, e[1] = r[1] = this.y + this.height, o(t, t, i), o(e, e, i), o(r, r, i), o(n, n, i), this.x = s(t[0], e[0], r[0], n[0]), this.y = s(t[1], e[1], r[1], n[1]); const a = l(t[0], e[0], r[0], n[0]); const h = l(t[1], e[1], r[1], n[1]); this.width = a - this.x, this.height = h - this.y } } }()), calculateTransform: function (t) { const e = this; const r = t.width / e.width; const n = t.height / e.height; const i = a.create(); return a.translate(i, i, [-e.x, -e.y]), a.scale(i, i, [r, n]), a.translate(i, i, [t.x, t.y]), i }, intersect: function (t) { if (!t) return !1; t instanceof n || (t = n.create(t)); const e = this; const r = e.x; const i = e.x + e.width; const a = e.y; const o = e.y + e.height; const s = t.x; const l = t.x + t.width; const h = t.y; const u = t.y + t.height; return !(i < s || l < r || o < h || u < a) }, contain: function (t, e) { const r = this; return t >= r.x && t <= r.x + r.width && e >= r.y && e <= r.y + r.height }, clone: function () { return new n(this.x, this.y, this.width, this.height) }, copy: function (t) { this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height }, plain: function () { return { x: this.x, y: this.y, width: this.width, height: this.height } } }, n.create = function (t) { return new n(t.x, t.y, t.width, t.height) }; const h = n; t.exports = h }, function (t, e, r) { function n (t) { return t > -b && t < b } function i (t) { return t > b || t < -b } function a (t, e, r, n, i) { const a = 1 - i; return a * a * (a * t + 3 * i * e) + i * i * (i * n + 3 * a * r) } function o (t, e, r, n, i) { const a = 1 - i; return 3 * (((e - t) * a + 2 * (r - e) * i) * a + (n - r) * i * i) } function s (t, e, r, i, a, o) { const s = i + 3 * (e - r) - t; const l = 3 * (r - 2 * e + t); const h = 3 * (e - t); const u = t - a; const c = l * l - 3 * s * h; const f = l * h - 9 * s * u; const d = h * h - 3 * l * u; let v = 0; if (n(c) && n(f)) if (n(l))o[0] = 0; else { var g = -h / l; g >= 0 && g <= 1 && (o[v++] = g) } else { const p = f * f - 4 * c * d; if (n(p)) { const m = f / c; var g = -l / s + m; var x = -m / 2; g >= 0 && g <= 1 && (o[v++] = g), x >= 0 && x <= 1 && (o[v++] = x) } else if (p > 0) { const y = _(p); let b = c * l + 1.5 * s * (-f + y); let S = c * l + 1.5 * s * (-f - y); b = b < 0 ? -w(-b, T) : w(b, T), S = S < 0 ? -w(-S, T) : w(S, T); var g = (-l - (b + S)) / (3 * s); g >= 0 && g <= 1 && (o[v++] = g) } else { const k = (2 * c * l - 3 * s * f) / (2 * _(c * c * c)); const C = Math.acos(k) / 3; const P = _(c); const I = Math.cos(C); var g = (-l - 2 * P * I) / (3 * s); var x = (-l + P * (I + M * Math.sin(C))) / (3 * s); const A = (-l + P * (I - M * Math.sin(C))) / (3 * s); g >= 0 && g <= 1 && (o[v++] = g), x >= 0 && x <= 1 && (o[v++] = x), A >= 0 && A <= 1 && (o[v++] = A) } } return v } function l (t, e, r, a, o) { const s = 6 * r - 12 * e + 6 * t; const l = 9 * e + 3 * a - 3 * t - 9 * r; const h = 3 * e - 3 * t; let u = 0; if (n(l)) { if (i(s)) { var c = -h / s; c >= 0 && c <= 1 && (o[u++] = c) } } else { const f = s * s - 4 * l * h; if (n(f))o[0] = -s / (2 * l); else if (f > 0) { const d = _(f); var c = (-s + d) / (2 * l); const v = (-s - d) / (2 * l); c >= 0 && c <= 1 && (o[u++] = c), v >= 0 && v <= 1 && (o[u++] = v) } } return u } function h (t, e, r, n, i, a) { const o = (e - t) * i + t; const s = (r - e) * i + e; const l = (n - r) * i + r; const h = (s - o) * i + o; const u = (l - s) * i + s; const c = (u - h) * i + h; a[0] = t, a[1] = o, a[2] = h, a[3] = c, a[4] = c, a[5] = u, a[6] = l, a[7] = n } function u (t, e, r, n, i, o, s, l, h, u, c) { let f; let d; let v; let g; let p; let m = 0.005; let x = 1 / 0; k[0] = h, k[1] = u; for (let w = 0; w < 1; w += 0.05)C[0] = a(t, r, i, s, w), C[1] = a(e, n, o, l, w), (g = y(k, C)) < x && (f = w, x = g); x = 1 / 0; for (let b = 0; b < 32 && !(m < S); b++)d = f - m, v = f + m, C[0] = a(t, r, i, s, d), C[1] = a(e, n, o, l, d), g = y(C, k), d >= 0 && g < x ? (f = d, x = g) : (P[0] = a(t, r, i, s, v), P[1] = a(e, n, o, l, v), p = y(P, k), v <= 1 && p < x ? (f = v, x = p) : m *= 0.5); return c && (c[0] = a(t, r, i, s, f), c[1] = a(e, n, o, l, f)), _(x) } function c (t, e, r, n) { const i = 1 - n; return i * (i * t + 2 * n * e) + n * n * r } function f (t, e, r, n) { return 2 * ((1 - n) * (e - t) + n * (r - e)) } function d (t, e, r, a, o) { const s = t - 2 * e + r; const l = 2 * (e - t); const h = t - a; let u = 0; if (n(s)) { if (i(l)) { var c = -h / l; c >= 0 && c <= 1 && (o[u++] = c) } } else { const f = l * l - 4 * s * h; if (n(f)) { var c = -l / (2 * s); c >= 0 && c <= 1 && (o[u++] = c) } else if (f > 0) { const d = _(f); var c = (-l + d) / (2 * s); const v = (-l - d) / (2 * s); c >= 0 && c <= 1 && (o[u++] = c), v >= 0 && v <= 1 && (o[u++] = v) } } return u } function v (t, e, r) { const n = t + r - 2 * e; return n === 0 ? 0.5 : (t - e) / n } function g (t, e, r, n, i) { const a = (e - t) * n + t; const o = (r - e) * n + e; const s = (o - a) * n + a; i[0] = t, i[1] = a, i[2] = s, i[3] = s, i[4] = o, i[5] = r } function p (t, e, r, n, i, a, o, s, l) { let h; let u = 0.005; let f = 1 / 0; k[0] = o, k[1] = s; for (let d = 0; d < 1; d += 0.05) { C[0] = c(t, r, i, d), C[1] = c(e, n, a, d); var v = y(k, C); v < f && (h = d, f = v) }f = 1 / 0; for (let g = 0; g < 32 && !(u < S); g++) { const p = h - u; const m = h + u; C[0] = c(t, r, i, p), C[1] = c(e, n, a, p); var v = y(C, k); if (p >= 0 && v < f)h = p, f = v; else { P[0] = c(t, r, i, m), P[1] = c(e, n, a, m); const x = y(P, k); m <= 1 && x < f ? (h = m, f = x) : u *= 0.5 } } return l && (l[0] = c(t, r, i, h), l[1] = c(e, n, a, h)), _(f) } const m = r(2); const x = m.create; var y = m.distSquare; var w = Math.pow; var _ = Math.sqrt; var b = 1e-8; var S = 1e-4; var M = _(3); var T = 1 / 3; var k = x(); var C = x(); var P = x(); e.cubicAt = a, e.cubicDerivativeAt = o, e.cubicRootAt = s, e.cubicExtrema = l, e.cubicSubdivide = h, e.cubicProjectPoint = u, e.quadraticAt = c, e.quadraticDerivativeAt = f, e.quadraticRootAt = d, e.quadraticExtremum = v, e.quadraticSubdivide = g, e.quadraticProjectPoint = p }, function (t, e, r) { function n (t, e) { L[t] = e } function i (t, e) { e = e || D; const r = t + ':' + e; if (P[r]) return P[r]; for (var n = (t + '').split('\n'), i = 0, a = 0, o = n.length; a < o; a++)i = Math.max(p(n[a], e).width, i); return I > A && (I = 0, P = {}), I++, P[r] = i, i } function a (t, e, r, n, i, a, l) { return a ? s(t, e, r, n, i, a, l) : o(t, e, r, n, i, l) } function o (t, e, r, n, a, o) { const s = m(t, e, a, o); let u = i(t, e); a && (u += a[1] + a[3]); const c = s.outerHeight; const f = l(0, u, r); const d = h(0, c, n); const v = new _(f, d, u, c); return v.lineHeight = s.lineHeight, v } function s (t, e, r, n, i, a, o) { const s = x(t, { rich: a, truncate: o, font: e, textAlign: r, textPadding: i }); const u = s.outerWidth; const c = s.outerHeight; const f = l(0, u, r); const d = h(0, c, n); return new _(f, d, u, c) } function l (t, e, r) { return r === 'right' ? t -= e : r === 'center' && (t -= e / 2), t } function h (t, e, r) { return r === 'middle' ? t -= e / 2 : r === 'bottom' && (t -= e), t } function u (t, e, r) { let n = e.x; let i = e.y; const a = e.height; const o = e.width; const s = a / 2; let l = 'left'; let h = 'top'; switch (t) { case 'left':n -= r, i += s, l = 'right', h = 'middle'; break; case 'right':n += r + o, i += s, h = 'middle'; break; case 'top':n += o / 2, i -= r, l = 'center', h = 'bottom'; break; case 'bottom':n += o / 2, i += a + r, l = 'center'; break; case 'inside':n += o / 2, i += s, l = 'center', h = 'middle'; break; case 'insideLeft':n += r, i += s, h = 'middle'; break; case 'insideRight':n += o - r, i += s, l = 'right', h = 'middle'; break; case 'insideTop':n += o / 2, i += r, l = 'center'; break; case 'insideBottom':n += o / 2, i += a - r, l = 'center', h = 'bottom'; break; case 'insideTopLeft':n += r, i += r; break; case 'insideTopRight':n += o - r, i += r, l = 'right'; break; case 'insideBottomLeft':n += r, i += a - r, h = 'bottom'; break; case 'insideBottomRight':n += o - r, i += a - r, l = 'right', h = 'bottom' } return { x: n, y: i, textAlign: l, textVerticalAlign: h } } function c (t, e, r, n, i) { if (!e) return ''; const a = (t + '').split('\n'); i = f(e, r, n, i); for (let o = 0, s = a.length; o < s; o++)a[o] = d(a[o], i); return a.join('\n') } function f (t, e, r, n) { n = T({}, n), n.font = e; var r = k(r, '...'); n.maxIterations = k(n.maxIterations, 2); const a = n.minChar = k(n.minChar, 0); n.cnCharWidth = i('国', e); const o = n.ascCharWidth = i('a', e); n.placeholder = k(n.placeholder, ''); for (var s = t = Math.max(0, t - 1), l = 0; l < a && s >= o; l++)s -= o; let h = i(r); return h > s && (r = '', h = 0), s = t - h, n.ellipsis = r, n.ellipsisWidth = h, n.contentWidth = s, n.containerWidth = t, n } function d (t, e) { const r = e.containerWidth; const n = e.font; const a = e.contentWidth; if (!r) return ''; let o = i(t, n); if (o <= r) return t; for (let s = 0; ;s++) { if (o <= a || s >= e.maxIterations) { t += e.ellipsis; break } const l = s === 0 ? v(t, a, e.ascCharWidth, e.cnCharWidth) : o > 0 ? Math.floor(t.length * a / o) : 0; t = t.substr(0, l), o = i(t, n) } return t === '' && (t = e.placeholder), t } function v (t, e, r, n) { for (var i = 0, a = 0, o = t.length; a < o && i < e; a++) { const s = t.charCodeAt(a); i += s >= 0 && s <= 127 ? r : n } return a } function g (t) { return i('国', t) } function p (t, e) { return L.measureText(t, e) } function m (t, e, r, n) { t != null && (t += ''); const i = g(e); let a = t ? t.split('\n') : []; const o = a.length * i; let s = o; if (r && (s += r[0] + r[2]), t && n) { const l = n.outerHeight; const h = n.outerWidth; if (l != null && s > l)t = '', a = []; else if (h != null) for (let u = f(h - (r ? r[1] + r[3] : 0), e, n.ellipsis, { minChar: n.minChar, placeholder: n.placeholder }), c = 0, v = a.length; c < v; c++)a[c] = d(a[c], u) } return { lines: a, height: o, outerHeight: s, lineHeight: i } } function x (t, e) { const r = { lines: [], width: 0, height: 0 }; if (t != null && (t += ''), !t) return r; for (var n, a = O.lastIndex = 0; (n = O.exec(t)) != null;) { const o = n.index; o > a && y(r, t.substring(a, o)), y(r, n[2], n[1]), a = O.lastIndex }a < t.length && y(r, t.substring(a, t.length)); const s = r.lines; let l = 0; let h = 0; const u = []; const f = e.textPadding; const d = e.truncate; let v = d && d.outerWidth; let p = d && d.outerHeight; f && (v != null && (v -= f[1] + f[3]), p != null && (p -= f[0] + f[2])); for (var m = 0; m < s.length; m++) { for (var x = s[m], w = 0, _ = 0, S = 0; S < x.tokens.length; S++) { var M = x.tokens[S]; const T = M.styleName && e.rich[M.styleName] || {}; const P = M.textPadding = T.textPadding; const I = M.font = T.font || e.font; let A = M.textHeight = k(T.textHeight, g(I)); if (P && (A += P[0] + P[2]), M.height = A, M.lineHeight = C(T.textLineHeight, e.textLineHeight, A), M.textAlign = T && T.textAlign || e.textAlign, M.textVerticalAlign = T && T.textVerticalAlign || 'middle', p != null && l + M.lineHeight > p) return { lines: [], width: 0, height: 0 }; M.textWidth = i(M.text, I); let D = T.textWidth; const L = D == null || D === 'auto'; if (typeof D === 'string' && D.charAt(D.length - 1) === '%')M.percentWidth = D, u.push(M), D = 0; else { if (L) { D = M.textWidth; const F = T.textBackgroundColor; let R = F && F.image; R && (R = b.findExistImage(R), b.isImageReady(R) && (D = Math.max(D, R.width * A / R.height))) } const B = P ? P[1] + P[3] : 0; D += B; const z = v != null ? v - _ : null; z != null && z < D && (!L || z < B ? (M.text = '', M.textWidth = D = 0) : (M.text = c(M.text, z - B, I, d.ellipsis, { minChar: d.minChar }), M.textWidth = i(M.text, I), D = M.textWidth + B)) }_ += M.width = D, T && (w = Math.max(w, M.lineHeight)) }x.width = _, x.lineHeight = w, l += w, h = Math.max(h, _) }r.outerWidth = r.width = k(e.textWidth, h), r.outerHeight = r.height = k(e.textHeight, l), f && (r.outerWidth += f[1] + f[3], r.outerHeight += f[0] + f[2]); for (var m = 0; m < u.length; m++) { var M = u[m]; const N = M.percentWidth; M.width = parseInt(N, 10) / 100 * h } return r } function y (t, e, r) { for (let n = e === '', i = e.split('\n'), a = t.lines, o = 0; o < i.length; o++) { const s = i[o]; const l = { styleName: r, text: s, isLineHolder: !s && !n }; if (o)a.push({ tokens: [l] }); else { const h = (a[a.length - 1] || (a[0] = { tokens: [] })).tokens; const u = h.length; u === 1 && h[0].isLineHolder ? h[0] = l : (s || !u || n) && h.push(l) } } } function w (t) { return (t.fontSize || t.fontFamily) && [t.fontStyle, t.fontWeight, (t.fontSize || 12) + 'px', t.fontFamily || 'sans-serif'].join(' ') || t.textFont || t.font } var _ = r(3); var b = r(10); const S = r(0); const M = S.getContext; var T = S.extend; var k = S.retrieve2; var C = S.retrieve3; var P = {}; var I = 0; var A = 5e3; var O = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g; var D = '12px sans-serif'; var L = {}; L.measureText = function (t, e) { const r = M(); return r.font = e || D, r.measureText(t) }, e.DEFAULT_FONT = D, e.$override = n, e.getWidth = i, e.getBoundingRect = a, e.adjustTextX = l, e.adjustTextY = h, e.adjustTextPositionOnRect = u, e.truncateText = c, e.getLineHeight = g, e.measureText = p, e.parsePlainText = m, e.parseRichText = x, e.makeFont = w }, function (t, e, r) { const n = r(4); const i = r(2); const a = r(49); const o = r(3); const s = r(19); const l = s.devicePixelRatio; const h = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 }; const u = []; const c = []; const f = []; const d = []; const v = Math.min; const g = Math.max; const p = Math.cos; const m = Math.sin; const x = Math.sqrt; const y = Math.abs; const w = typeof Float32Array !== 'undefined'; const _ = function (t) { this._saveData = !t, this._saveData && (this.data = []), this._ctx = null }; _.prototype = { constructor: _, _xi: 0, _yi: 0, _x0: 0, _y0: 0, _ux: 0, _uy: 0, _len: 0, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, setScale: function (t, e) { this._ux = y(1 / l / t) || 0, this._uy = y(1 / l / e) || 0 }, getContext: function () { return this._ctx }, beginPath: function (t) { return this._ctx = t, t && t.beginPath(), t && (this.dpr = t.dpr), this._saveData && (this._len = 0), this._lineDash && (this._lineDash = null, this._dashOffset = 0), this }, moveTo: function (t, e) { return this.addData(h.M, t, e), this._ctx && this._ctx.moveTo(t, e), this._x0 = t, this._y0 = e, this._xi = t, this._yi = e, this }, lineTo: function (t, e) { const r = y(t - this._xi) > this._ux || y(e - this._yi) > this._uy || this._len < 5; return this.addData(h.L, t, e), this._ctx && r && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)), r && (this._xi = t, this._yi = e), this }, bezierCurveTo: function (t, e, r, n, i, a) { return this.addData(h.C, t, e, r, n, i, a), this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, r, n, i, a) : this._ctx.bezierCurveTo(t, e, r, n, i, a)), this._xi = i, this._yi = a, this }, quadraticCurveTo: function (t, e, r, n) { return this.addData(h.Q, t, e, r, n), this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, r, n) : this._ctx.quadraticCurveTo(t, e, r, n)), this._xi = r, this._yi = n, this }, arc: function (t, e, r, n, i, a) { return this.addData(h.A, t, e, r, r, n, i - n, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, e, r, n, i, a), this._xi = p(i) * r + t, this._yi = m(i) * r + t, this }, arcTo: function (t, e, r, n, i) { return this._ctx && this._ctx.arcTo(t, e, r, n, i), this }, rect: function (t, e, r, n) { return this._ctx && this._ctx.rect(t, e, r, n), this.addData(h.R, t, e, r, n), this }, closePath: function () { this.addData(h.Z); const t = this._ctx; const e = this._x0; const r = this._y0; return t && (this._needsDash() && this._dashedLineTo(e, r), t.closePath()), this._xi = e, this._yi = r, this }, fill: function (t) { t && t.fill(), this.toStatic() }, stroke: function (t) { t && t.stroke(), this.toStatic() }, setLineDash: function (t) { if (t instanceof Array) { this._lineDash = t, this._dashIdx = 0; for (var e = 0, r = 0; r < t.length; r++)e += t[r]; this._dashSum = e } return this }, setLineDashOffset: function (t) { return this._dashOffset = t, this }, len: function () { return this._len }, setData: function (t) { const e = t.length; this.data && this.data.length == e || !w || (this.data = new Float32Array(e)); for (let r = 0; r < e; r++) this.data[r] = t[r]; this._len = e }, appendPath: function (t) { t instanceof Array || (t = [t]); for (var e = t.length, r = 0, n = this._len, i = 0; i < e; i++)r += t[i].len(); w && this.data instanceof Float32Array && (this.data = new Float32Array(n + r)); for (var i = 0; i < e; i++) for (let a = t[i].data, o = 0; o < a.length; o++) this.data[n++] = a[o]; this._len = n }, addData: function (t) { if (this._saveData) { let e = this.data; this._len + arguments.length > e.length && (this._expandData(), e = this.data); for (let r = 0; r < arguments.length; r++)e[this._len++] = arguments[r]; this._prevCmd = t } }, _expandData: function () { if (!(this.data instanceof Array)) { for (var t = [], e = 0; e < this._len; e++)t[e] = this.data[e]; this.data = t } }, _needsDash: function () { return this._lineDash }, _dashedLineTo: function (t, e) { let r; let n; const i = this._dashSum; let a = this._dashOffset; const o = this._lineDash; const s = this._ctx; const l = this._xi; const h = this._yi; let u = t - l; let c = e - h; const f = x(u * u + c * c); let d = l; let p = h; const m = o.length; for (u /= f, c /= f, a < 0 && (a = i + a), a %= i, d -= a * u, p -= a * c; u > 0 && d <= t || u < 0 && d >= t || u == 0 && (c > 0 && p <= e || c < 0 && p >= e);)n = this._dashIdx, r = o[n], d += u * r, p += c * r, this._dashIdx = (n + 1) % m, u > 0 && d < l || u < 0 && d > l || c > 0 && p < h || c < 0 && p > h || s[n % 2 ? 'moveTo' : 'lineTo'](u >= 0 ? v(d, t) : g(d, t), c >= 0 ? v(p, e) : g(p, e)); u = d - t, c = p - e, this._dashOffset = -x(u * u + c * c) }, _dashedBezierTo: function (t, e, r, i, a, o) { let s; let l; let h; let u; let c; const f = this._dashSum; let d = this._dashOffset; const v = this._lineDash; const g = this._ctx; const p = this._xi; const m = this._yi; const y = n.cubicAt; let w = 0; let _ = this._dashIdx; const b = v.length; let S = 0; for (d < 0 && (d = f + d), d %= f, s = 0; s < 1; s += 0.1)l = y(p, t, r, a, s + 0.1) - y(p, t, r, a, s), h = y(m, e, i, o, s + 0.1) - y(m, e, i, o, s), w += x(l * l + h * h); for (;_ < b && !((S += v[_]) > d); _++);for (s = (S - d) / w; s <= 1;)u = y(p, t, r, a, s), c = y(m, e, i, o, s), _ % 2 ? g.moveTo(u, c) : g.lineTo(u, c), s += v[_] / w, _ = (_ + 1) % b; _ % 2 != 0 && g.lineTo(a, o), l = a - u, h = o - c, this._dashOffset = -x(l * l + h * h) }, _dashedQuadraticTo: function (t, e, r, n) { const i = r; const a = n; r = (r + 2 * t) / 3, n = (n + 2 * e) / 3, t = (this._xi + 2 * t) / 3, e = (this._yi + 2 * e) / 3, this._dashedBezierTo(t, e, r, n, i, a) }, toStatic: function () { const t = this.data; t instanceof Array && (t.length = this._len, w && (this.data = new Float32Array(t))) }, getBoundingRect: function () { u[0] = u[1] = f[0] = f[1] = Number.MAX_VALUE, c[0] = c[1] = d[0] = d[1] = -Number.MAX_VALUE; for (var t = this.data, e = 0, r = 0, n = 0, s = 0, l = 0; l < t.length;) { const v = t[l++]; switch (l == 1 && (e = t[l], r = t[l + 1], n = e, s = r), v) { case h.M:n = t[l++], s = t[l++], e = n, r = s, f[0] = n, f[1] = s, d[0] = n, d[1] = s; break; case h.L:a.fromLine(e, r, t[l], t[l + 1], f, d), e = t[l++], r = t[l++]; break; case h.C:a.fromCubic(e, r, t[l++], t[l++], t[l++], t[l++], t[l], t[l + 1], f, d), e = t[l++], r = t[l++]; break; case h.Q:a.fromQuadratic(e, r, t[l++], t[l++], t[l], t[l + 1], f, d), e = t[l++], r = t[l++]; break; case h.A:var g = t[l++]; var x = t[l++]; var y = t[l++]; var w = t[l++]; var _ = t[l++]; var b = t[l++] + _; var S = (t[l++], 1 - t[l++]); l == 1 && (n = p(_) * y + g, s = m(_) * w + x), a.fromArc(g, x, y, w, _, b, S, f, d), e = p(b) * y + g, r = m(b) * w + x; break; case h.R:n = e = t[l++], s = r = t[l++]; var M = t[l++]; var T = t[l++]; a.fromLine(n, s, n + M, s + T, f, d); break; case h.Z:e = n, r = s }i.min(u, u, f), i.max(c, c, d) } return l === 0 && (u[0] = u[1] = c[0] = c[1] = 0), new o(u[0], u[1], c[0] - u[0], c[1] - u[1]) }, rebuildPath: function (t) { for (var e, r, n, i, a, o, s = this.data, l = this._ux, u = this._uy, c = this._len, f = 0; f < c;) { const d = s[f++]; switch (f == 1 && (n = s[f], i = s[f + 1], e = n, r = i), d) { case h.M:e = n = s[f++], r = i = s[f++], t.moveTo(n, i); break; case h.L:a = s[f++], o = s[f++], (y(a - n) > l || y(o - i) > u || f === c - 1) && (t.lineTo(a, o), n = a, i = o); break; case h.C:t.bezierCurveTo(s[f++], s[f++], s[f++], s[f++], s[f++], s[f++]), n = s[f - 2], i = s[f - 1]; break; case h.Q:t.quadraticCurveTo(s[f++], s[f++], s[f++], s[f++]), n = s[f - 2], i = s[f - 1]; break; case h.A:var v = s[f++]; var g = s[f++]; var x = s[f++]; var w = s[f++]; var _ = s[f++]; var b = s[f++]; var S = s[f++]; var M = s[f++]; var T = x > w ? x : w; var k = x > w ? 1 : x / w; var C = x > w ? w / x : 1; var P = Math.abs(x - w) > 0.001; var I = _ + b; P ? (t.translate(v, g), t.rotate(S), t.scale(k, C), t.arc(0, 0, T, _, I, 1 - M), t.scale(1 / k, 1 / C), t.rotate(-S), t.translate(-v, -g)) : t.arc(v, g, T, _, I, 1 - M), f == 1 && (e = p(_) * x + v, r = m(_) * w + g), n = p(I) * x + v, i = m(I) * w + g; break; case h.R:e = n = s[f], r = i = s[f + 1], t.rect(s[f++], s[f++], s[f++], s[f++]); break; case h.Z:t.closePath(), n = e, i = r } } } }, _.CMD = h; const b = _; t.exports = b }, function (e, r) { e.exports = t }, function (t, e) { function r () { const t = new u(6); return n(t), t } function n (t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t } function i (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t } function a (t, e, r) { const n = e[0] * r[0] + e[2] * r[1]; const i = e[1] * r[0] + e[3] * r[1]; const a = e[0] * r[2] + e[2] * r[3]; const o = e[1] * r[2] + e[3] * r[3]; const s = e[0] * r[4] + e[2] * r[5] + e[4]; const l = e[1] * r[4] + e[3] * r[5] + e[5]; return t[0] = n, t[1] = i, t[2] = a, t[3] = o, t[4] = s, t[5] = l, t } function o (t, e, r) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4] + r[0], t[5] = e[5] + r[1], t } function s (t, e, r) { const n = e[0]; const i = e[2]; const a = e[4]; const o = e[1]; const s = e[3]; const l = e[5]; const h = Math.sin(r); const u = Math.cos(r); return t[0] = n * u + o * h, t[1] = -n * h + o * u, t[2] = i * u + s * h, t[3] = -i * h + u * s, t[4] = u * a + h * l, t[5] = u * l - h * a, t } function l (t, e, r) { const n = r[0]; const i = r[1]; return t[0] = e[0] * n, t[1] = e[1] * i, t[2] = e[2] * n, t[3] = e[3] * i, t[4] = e[4] * n, t[5] = e[5] * i, t } function h (t, e) { const r = e[0]; const n = e[2]; const i = e[4]; const a = e[1]; const o = e[3]; const s = e[5]; let l = r * o - a * n; return l ? (l = 1 / l, t[0] = o * l, t[1] = -a * l, t[2] = -n * l, t[3] = r * l, t[4] = (n * s - o * i) * l, t[5] = (a * i - r * s) * l, t) : null } var u = typeof Float32Array === 'undefined' ? Array : Float32Array; e.create = r, e.identity = n, e.copy = i, e.mul = a, e.translate = o, e.rotate = s, e.scale = l, e.invert = h }, function (t, e, r) { function n (t) { return t.replace(/^\s+/, '').replace(/\s+$/, '') } function i (t, e, r, n) { const i = e[1] - e[0]; const a = r[1] - r[0]; if (i === 0) return a === 0 ? r[0] : (r[0] + r[1]) / 2; if (n) if (i > 0) { if (t <= e[0]) return r[0]; if (t >= e[1]) return r[1] } else { if (t >= e[0]) return r[0]; if (t <= e[1]) return r[1] } else { if (t === e[0]) return r[0]; if (t === e[1]) return r[1] } return (t - e[0]) / i * a + r[0] } function a (t, e) { switch (t) { case 'center':case 'middle':t = '50%'; break; case 'left':case 'top':t = '0%'; break; case 'right':case 'bottom':t = '100%' } return typeof t === 'string' ? n(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : t == null ? NaN : +t } function o (t, e, r) { return e == null && (e = 10), e = Math.min(Math.max(0, e), 20), t = (+t).toFixed(e), r ? t : +t } function s (t) { return t.sort(function (t, e) { return t - e }), t } function l (t) { if (t = +t, isNaN(t)) return 0; for (var e = 1, r = 0; Math.round(t * e) / e !== t;)e *= 10, r++; return r } function h (t) { const e = t.toString(); const r = e.indexOf('e'); if (r > 0) { const n = +e.slice(r + 1); return n < 0 ? -n : 0 } const i = e.indexOf('.'); return i < 0 ? 0 : e.length - 1 - i } function u (t, e) { const r = Math.log; const n = Math.LN10; const i = Math.floor(r(t[1] - t[0]) / n); const a = Math.round(r(Math.abs(e[1] - e[0])) / n); const o = Math.min(Math.max(-i + a, 0), 20); return isFinite(o) ? o : 20 } function c (t, e, r) { if (!t[e]) return 0; const n = w.reduce(t, function (t, e) { return t + (isNaN(e) ? 0 : e) }, 0); if (n === 0) return 0; for (var i = Math.pow(10, r), a = w.map(t, function (t) { return (isNaN(t) ? 0 : t) / n * i * 100 }), o = 100 * i, s = w.map(a, function (t) { return Math.floor(t) }), l = w.reduce(s, function (t, e) { return t + e }, 0), h = w.map(a, function (t, e) { return t - s[e] }); l < o;) { for (var u = Number.NEGATIVE_INFINITY, c = null, f = 0, d = h.length; f < d; ++f)h[f] > u && (u = h[f], c = f); ++s[c], h[c] = 0, ++l } return s[e] / i } function f (t) { const e = 2 * Math.PI; return (t % e + e) % e } function d (t) { return t > -_ && t < _ } function v (t) { if (t instanceof Date) return t; if (typeof t === 'string') { const e = b.exec(t); if (!e) return new Date(NaN); if (e[8]) { let r = +e[4] || 0; return e[8].toUpperCase() !== 'Z' && (r -= e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, r, +(e[5] || 0), +e[6] || 0, +e[7] || 0)) } return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, +e[7] || 0) } return t == null ? new Date(NaN) : new Date(Math.round(t)) } function g (t) { return Math.pow(10, p(t)) } function p (t) { return Math.floor(Math.log(t) / Math.LN10) } function m (t, e) { let r; const n = p(t); const i = Math.pow(10, n); const a = t / i; return r = e ? a < 1.5 ? 1 : a < 2.5 ? 2 : a < 4 ? 3 : a < 7 ? 5 : 10 : a < 1 ? 1 : a < 2 ? 2 : a < 3 ? 3 : a < 5 ? 5 : 10, t = r * i, n >= -20 ? +t.toFixed(n < 0 ? -n : 0) : t } function x (t) { function e (t, r, n) { return t.interval[n] < r.interval[n] || t.interval[n] === r.interval[n] && (t.close[n] - r.close[n] == (n ? -1 : 1) || !n && e(t, r, 1)) }t.sort(function (t, r) { return e(t, r, 0) ? -1 : 1 }); for (let r = -1 / 0, n = 1, i = 0; i < t.length;) { for (var a = t[i].interval, o = t[i].close, s = 0; s < 2; s++)a[s] <= r && (a[s] = r, o[s] = s ? 1 : 1 - n), r = a[s], n = o[s]; a[0] === a[1] && o[0] * o[1] != 1 ? t.splice(i, 1) : i++ } return t } function y (t) { return t - parseFloat(t) >= 0 } var w = r(0); var _ = 1e-4; var b = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; e.linearMap = i, e.parsePercent = a, e.round = o, e.asc = s, e.getPrecision = l, e.getPrecisionSafe = h, e.getPixelPrecision = u, e.getPercentWithPrecision = c, e.MAX_SAFE_INTEGER = 9007199254740991, e.remRadian = f, e.isRadianAroundZero = d, e.parseDate = v, e.quantity = g, e.nice = m, e.reformIntervals = x, e.isNumeric = y }, function (t, e, r) { function n (t) { if (typeof t === 'string') { const e = l.get(t); return e && e.image } return t } function i (t, e, r, n, i) { if (t) { if (typeof t === 'string') { if (e && e.__zrImageSrc === t || !r) return e; const s = l.get(t); const h = { hostEl: r, cb: n, cbPayload: i }; return s ? (e = s.image, !o(e) && s.pending.push(h)) : (!e && (e = new Image()), e.onload = a, l.put(t, e.__cachedImgObj = { image: e, pending: [h] }), e.src = e.__zrImageSrc = t), e } return t } return e } function a () { const t = this.__cachedImgObj; this.onload = this.__cachedImgObj = null; for (let e = 0; e < t.pending.length; e++) { const r = t.pending[e]; const n = r.cb; n && n(this, r.cbPayload), r.hostEl.dirty() }t.pending.length = 0 } function o (t) { return t && t.width && t.height } const s = r(14); var l = new s(50); e.findExistImage = n, e.createOrUpdateImage = i, e.isImageReady = o }, function (t, e, r) { function n (t) { for (let e = 0; e < t.length; e++)t[e][1] || (t[e][1] = t[e][0]); return function (e, r, n) { for (var a = {}, o = 0; o < t.length; o++) { const s = t[o][1]; if (!(r && i.indexOf(r, s) >= 0 || n && i.indexOf(n, s) < 0)) { const l = e.getShallow(s); l != null && (a[t[o][0]] = l) } } return a } } var i = r(0); t.exports = n }, function (t, e, r) { function n (t) { t = t || {}, o.call(this, t); for (const e in t)t.hasOwnProperty(e) && e !== 'style' && (this[e] = t[e]); this.style = new a(t.style, this), this._rect = null, this.__clipPaths = [] } const i = r(0); var a = r(40); var o = r(16); const s = r(48); n.prototype = { constructor: n, type: 'displayable', __dirty: !0, invisible: !1, z: 0, z2: 0, zlevel: 0, draggable: !1, dragging: !1, silent: !1, culling: !1, cursor: 'pointer', rectHover: !1, progressive: -1, beforeBrush: function (t) {}, afterBrush: function (t) {}, brush: function (t, e) {}, getBoundingRect: function () {}, contain: function (t, e) { return this.rectContain(t, e) }, traverse: function (t, e) { t.call(e, this) }, rectContain: function (t, e) { const r = this.transformCoordToLocal(t, e); return this.getBoundingRect().contain(r[0], r[1]) }, dirty: function () { this.__dirty = !0, this._rect = null, this.__zr && this.__zr.refresh() }, animateStyle: function (t) { return this.animate('style', t) }, attrKV: function (t, e) { t !== 'style' ? o.prototype.attrKV.call(this, t, e) : this.style.set(e) }, setStyle: function (t, e) { return this.style.set(t, e), this.dirty(!1), this }, useStyle: function (t) { return this.style = new a(t, this), this.dirty(!1), this } }, i.inherits(n, o), i.mixin(n, s); const l = n; t.exports = l }, function (t, e, r) { function n (t) { return isNaN(t) ? '-' : (t = (t + '').split('.'), t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (t.length > 1 ? '.' + t[1] : '')) } function i (t, e) { return t = (t || '').toLowerCase().replace(/-(.)/g, function (t, e) { return e.toUpperCase() }), e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)), t } function a (t) { return String(t).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;') } function o (t, e, r) { c.isArray(e) || (e = [e]); const n = e.length; if (!n) return ''; for (var i = e[0].$vars || [], o = 0; o < i.length; o++) { const s = g[o]; var l = p(s, 0); t = t.replace(p(s), r ? a(l) : l) } for (let h = 0; h < n; h++) for (let u = 0; u < i.length; u++) { var l = e[h][i[u]]; t = t.replace(p(g[u], h), r ? a(l) : l) } return t } function s (t, e, r) { return c.each(e, function (e, n) { t = t.replace('{' + n + '}', r ? a(e) : e) }), t } function l (t, e) { return t ? '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + a(t) + ';' + (e || '') + '"></span>' : '' } function h (t, e, r) { t !== 'week' && t !== 'month' && t !== 'quarter' && t !== 'half-year' && t !== 'year' || (t = 'MM-dd\nyyyy'); const n = d.parseDate(e); const i = r ? 'UTC' : ''; const a = n['get' + i + 'FullYear'](); const o = n['get' + i + 'Month']() + 1; const s = n['get' + i + 'Date'](); const l = n['get' + i + 'Hours'](); const h = n['get' + i + 'Minutes'](); const u = n['get' + i + 'Seconds'](); return t = t.replace('MM', m(o)).replace('M', o).replace('yyyy', a).replace('yy', a % 100).replace('dd', m(s)).replace('d', s).replace('hh', m(l)).replace('h', l).replace('mm', m(h)).replace('m', h).replace('ss', m(u)).replace('s', u) } function u (t) { return t ? t.charAt(0).toUpperCase() + t.substr(1) : t } var c = r(0); const f = r(5); var d = r(9); const v = c.normalizeCssArray; var g = ['a', 'b', 'c', 'd', 'e', 'f', 'g']; var p = function (t, e) { return '{' + t + (e == null ? '' : e) + '}' }; var m = function (t) { return t < 10 ? '0' + t : t }; const x = f.truncateText; const y = f.getBoundingRect; e.addCommas = n, e.toCamelCase = i, e.normalizeCssArray = v, e.encodeHTML = a, e.formatTpl = o, e.formatTplSimple = s, e.getTooltipMarker = l, e.formatTime = h, e.capitalFirst = u, e.truncateText = x, e.getTextRect = y }, function (t, e) { const r = function () { this.head = null, this.tail = null, this._len = 0 }; const n = r.prototype; n.insert = function (t) { const e = new i(t); return this.insertEntry(e), e }, n.insertEntry = function (t) { this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++ }, n.remove = function (t) { const e = t.prev; const r = t.next; e ? e.next = r : this.head = r, r ? r.prev = e : this.tail = e, t.next = t.prev = null, this._len-- }, n.len = function () { return this._len }, n.clear = function () { this.head = this.tail = null, this._len = 0 }; var i = function (t) { this.value = t, this.next, this.prev }; const a = function (t) { this._list = new r(), this._map = {}, this._maxSize = t || 10, this._lastRemovedEntry = null }; const o = a.prototype; o.put = function (t, e) { const r = this._list; const n = this._map; let a = null; if (n[t] == null) { const o = r.len(); let s = this._lastRemovedEntry; if (o >= this._maxSize && o > 0) { const l = r.head; r.remove(l), delete n[l.key], a = l.value, this._lastRemovedEntry = l }s ? s.value = e : s = new i(e), s.key = t, r.insertEntry(s), n[t] = s } return a }, o.get = function (t) { const e = this._map[t]; const r = this._list; if (e != null) return e !== r.tail && (r.remove(e), r.insertEntry(e)), e.value }, o.clear = function () { this._list.clear(), this._map = {} }; const s = a; t.exports = s }, function (t, e) { let r = {}; r = typeof navigator === 'undefined' ? { browser: {}, os: {}, node: !0, canvasSupported: !0, svgSupported: !0 } : (function (t) { const e = {}; const r = {}; const n = t.match(/Firefox\/([\d.]+)/); const i = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/); const a = t.match(/Edge\/([\d.]+)/); const o = /micromessenger/i.test(t); return n && (r.firefox = !0, r.version = n[1]), i && (r.ie = !0, r.version = i[1]), a && (r.edge = !0, r.version = a[1]), o && (r.weChat = !0), { browser: r, os: e, node: !1, canvasSupported: !!document.createElement('canvas').getContext, svgSupported: typeof SVGRect !== 'undefined', touchEventsSupported: 'ontouchstart' in window && !r.ie && !r.edge, pointerEventsSupported: 'onpointerdown' in window && (r.edge || r.ie && r.version >= 11) } }(navigator.userAgent)); const n = r; t.exports = n }, function (t, e, r) { const n = r(41); const i = r(42); const a = r(17); const o = r(43); const s = r(0); const l = function (t) { a.call(this, t), i.call(this, t), o.call(this, t), this.id = t.id || n() }; l.prototype = { type: 'element', name: '', __zr: null, ignore: !1, clipPath: null, drift: function (t, e) { switch (this.draggable) { case 'horizontal':e = 0; break; case 'vertical':t = 0 } let r = this.transform; r || (r = this.transform = [1, 0, 0, 1, 0, 0]), r[4] += t, r[5] += e, this.decomposeTransform(), this.dirty(!1) }, beforeUpdate: function () {}, afterUpdate: function () {}, update: function () { this.updateTransform() }, traverse: function (t, e) {}, attrKV: function (t, e) { if (t === 'position' || t === 'scale' || t === 'origin') { if (e) { let r = this[t]; r || (r = this[t] = []), r[0] = e[0], r[1] = e[1] } } else this[t] = e }, hide: function () { this.ignore = !0, this.__zr && this.__zr.refresh() }, show: function () { this.ignore = !1, this.__zr && this.__zr.refresh() }, attr: function (t, e) { if (typeof t === 'string') this.attrKV(t, e); else if (s.isObject(t)) for (const r in t)t.hasOwnProperty(r) && this.attrKV(r, t[r]); return this.dirty(!1), this }, setClipPath: function (t) { const e = this.__zr; e && t.addSelfToZr(e), this.clipPath && this.clipPath !== t && this.removeClipPath(), this.clipPath = t, t.__zr = e, t.__clipTarget = this, this.dirty(!1) }, removeClipPath: function () { const t = this.clipPath; t && (t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__clipTarget = null, this.clipPath = null, this.dirty(!1)) }, addSelfToZr: function (t) { this.__zr = t; const e = this.animators; if (e) for (let r = 0; r < e.length; r++)t.animation.addAnimator(e[r]); this.clipPath && this.clipPath.addSelfToZr(t) }, removeSelfFromZr: function (t) { this.__zr = null; const e = this.animators; if (e) for (let r = 0; r < e.length; r++)t.animation.removeAnimator(e[r]); this.clipPath && this.clipPath.removeSelfFromZr(t) } }, s.mixin(l, o), s.mixin(l, a), s.mixin(l, i); const h = l; t.exports = h }, function (t, e, r) { function n (t) { return t > s || t < -s } const i = r(8); const a = r(2); const o = i.identity; var s = 5e-5; const l = function (t) { t = t || {}, t.position || (this.position = [0, 0]), t.rotation == null && (this.rotation = 0), t.scale || (this.scale = [1, 1]), this.origin = this.origin || null }; const h = l.prototype; h.transform = null, h.needLocalTransform = function () { return n(this.rotation) || n(this.position[0]) || n(this.position[1]) || n(this.scale[0] - 1) || n(this.scale[1] - 1) }, h.updateTransform = function () { const t = this.parent; const e = t && t.transform; const r = this.needLocalTransform(); let n = this.transform; if (!r && !e) return void (n && o(n)); n = n || i.create(), r ? this.getLocalTransform(n) : o(n), e && (r ? i.mul(n, t.transform, n) : i.copy(n, t.transform)), this.transform = n, this.invTransform = this.invTransform || i.create(), i.invert(this.invTransform, n) }, h.getLocalTransform = function (t) { return l.getLocalTransform(this, t) }, h.setTransform = function (t) { const e = this.transform; const r = t.dpr || 1; e ? t.setTransform(r * e[0], r * e[1], r * e[2], r * e[3], r * e[4], r * e[5]) : t.setTransform(r, 0, 0, r, 0, 0) }, h.restoreTransform = function (t) { const e = t.dpr || 1; t.setTransform(e, 0, 0, e, 0, 0) }; const u = []; h.decomposeTransform = function () { if (this.transform) { const t = this.parent; let e = this.transform; t && t.transform && (i.mul(u, t.invTransform, e), e = u); let r = e[0] * e[0] + e[1] * e[1]; let a = e[2] * e[2] + e[3] * e[3]; const o = this.position; const s = this.scale; n(r - 1) && (r = Math.sqrt(r)), n(a - 1) && (a = Math.sqrt(a)), e[0] < 0 && (r = -r), e[3] < 0 && (a = -a), o[0] = e[4], o[1] = e[5], s[0] = r, s[1] = a, this.rotation = Math.atan2(-e[1] / a, e[0] / r) } }, h.getGlobalScale = function () { const t = this.transform; if (!t) return [1, 1]; let e = Math.sqrt(t[0] * t[0] + t[1] * t[1]); let r = Math.sqrt(t[2] * t[2] + t[3] * t[3]); return t[0] < 0 && (e = -e), t[3] < 0 && (r = -r), [e, r] }, h.transformCoordToLocal = function (t, e) { const r = [t, e]; const n = this.invTransform; return n && a.applyTransform(r, r, n), r }, h.transformCoordToGlobal = function (t, e) { const r = [t, e]; const n = this.transform; return n && a.applyTransform(r, r, n), r }, l.getLocalTransform = function (t, e) { e = e || [], o(e); const r = t.origin; const n = t.scale || [1, 1]; const a = t.rotation || 0; const s = t.position || [0, 0]; return r && (e[4] -= r[0], e[5] -= r[1]), i.scale(e, e, n), a && i.rotate(e, e, a), r && (e[4] += r[0], e[5] += r[1]), e[4] += s[0], e[5] += s[1], e }; const c = l; t.exports = c }, function (t, e, r) { function n (t) { return t = Math.round(t), t < 0 ? 0 : t > 255 ? 255 : t } function i (t) { return t = Math.round(t), t < 0 ? 0 : t > 360 ? 360 : t } function a (t) { return t < 0 ? 0 : t > 1 ? 1 : t } function o (t) { return n(t.length && t.charAt(t.length - 1) === '%' ? parseFloat(t) / 100 * 255 : parseInt(t, 10)) } function s (t) { return a(t.length && t.charAt(t.length - 1) === '%' ? parseFloat(t) / 100 : parseFloat(t)) } function l (t, e, r) { return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t } function h (t, e, r) { return t + (e - t) * r } function u (t, e, r, n, i) { return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t } function c (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t } function f (t, e) { k && c(k, e), k = T.put(t, k || e.slice()) } function d (t, e) { if (t) { e = e || []; const r = T.get(t); if (r) return c(e, r); t += ''; const n = t.replace(/ /g, '').toLowerCase(); if (n in M) return c(e, M[n]), f(t, e), e; if (n.charAt(0) !== '#') { const i = n.indexOf('('); const a = n.indexOf(')'); if (i !== -1 && a + 1 === n.length) { const l = n.substr(0, i); const h = n.substr(i + 1, a - (i + 1)).split(','); let d = 1; switch (l) { case 'rgba':if (h.length !== 4) return void u(e, 0, 0, 0, 1); d = s(h.pop()); case 'rgb':return h.length !== 3 ? void u(e, 0, 0, 0, 1) : (u(e, o(h[0]), o(h[1]), o(h[2]), d), f(t, e), e); case 'hsla':return h.length !== 4 ? void u(e, 0, 0, 0, 1) : (h[3] = s(h[3]), v(h, e), f(t, e), e); case 'hsl':return h.length !== 3 ? void u(e, 0, 0, 0, 1) : (v(h, e), f(t, e), e); default:return } }u(e, 0, 0, 0, 1) } else { if (n.length === 4) { var g = parseInt(n.substr(1), 16); return g >= 0 && g <= 4095 ? (u(e, (3840 & g) >> 4 | (3840 & g) >> 8, 240 & g | (240 & g) >> 4, 15 & g | (15 & g) << 4, 1), f(t, e), e) : void u(e, 0, 0, 0, 1) } if (n.length === 7) { var g = parseInt(n.substr(1), 16); return g >= 0 && g <= 16777215 ? (u(e, (16711680 & g) >> 16, (65280 & g) >> 8, 255 & g, 1), f(t, e), e) : void u(e, 0, 0, 0, 1) } } } } function v (t, e) { const r = (parseFloat(t[0]) % 360 + 360) % 360 / 360; const i = s(t[1]); const a = s(t[2]); const o = a <= 0.5 ? a * (i + 1) : a + i - a * i; const h = 2 * a - o; return e = e || [], u(e, n(255 * l(h, o, r + 1 / 3)), n(255 * l(h, o, r)), n(255 * l(h, o, r - 1 / 3)), 1), t.length === 4 && (e[3] = t[3]), e } function g (t) { if (t) { let e; let r; const n = t[0] / 255; const i = t[1] / 255; const a = t[2] / 255; const o = Math.min(n, i, a); const s = Math.max(n, i, a); const l = s - o; const h = (s + o) / 2; if (l === 0)e = 0, r = 0; else { r = h < 0.5 ? l / (s + o) : l / (2 - s - o); const u = ((s - n) / 6 + l / 2) / l; const c = ((s - i) / 6 + l / 2) / l; const f = ((s - a) / 6 + l / 2) / l; n === s ? e = f - c : i === s ? e = 1 / 3 + u - f : a === s && (e = 2 / 3 + c - u), e < 0 && (e += 1), e > 1 && (e -= 1) } const d = [360 * e, r, h]; return t[3] != null && d.push(t[3]), d } } function p (t, e) { const r = d(t); if (r) { for (let n = 0; n < 3; n++)r[n] = e < 0 ? r[n] * (1 - e) | 0 : (255 - r[n]) * e + r[n] | 0; return b(r, r.length === 4 ? 'rgba' : 'rgb') } } function m (t) { const e = d(t); if (e) return ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1) } function x (t, e, r) { if (e && e.length && t >= 0 && t <= 1) { r = r || []; const i = t * (e.length - 1); const o = Math.floor(i); const s = Math.ceil(i); const l = e[o]; const u = e[s]; const c = i - o; return r[0] = n(h(l[0], u[0], c)), r[1] = n(h(l[1], u[1], c)), r[2] = n(h(l[2], u[2], c)), r[3] = a(h(l[3], u[3], c)), r } } function y (t, e, r) { if (e && e.length && t >= 0 && t <= 1) { const i = t * (e.length - 1); const o = Math.floor(i); const s = Math.ceil(i); const l = d(e[o]); const u = d(e[s]); const c = i - o; const f = b([n(h(l[0], u[0], c)), n(h(l[1], u[1], c)), n(h(l[2], u[2], c)), a(h(l[3], u[3], c))], 'rgba'); return r ? { color: f, leftIndex: o, rightIndex: s, value: i } : f } } function w (t, e, r, n) { if (t = d(t)) return t = g(t), e != null && (t[0] = i(e)), r != null && (t[1] = s(r)), n != null && (t[2] = s(n)), b(v(t), 'rgba') } function _ (t, e) { if ((t = d(t)) && e != null) return t[3] = a(e), b(t, 'rgba') } function b (t, e) { if (t && t.length) { let r = t[0] + ',' + t[1] + ',' + t[2]; return e !== 'rgba' && e !== 'hsva' && e !== 'hsla' || (r += ',' + t[3]), e + '(' + r + ')' } } const S = r(14); var M = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] }; var T = new S(20); var k = null; const C = x; const P = y; e.parse = d, e.lift = p, e.toHex = m, e.fastLerp = x, e.fastMapToColor = C, e.lerp = y, e.mapToColor = P, e.modifyHSL = w, e.modifyAlpha = _, e.stringify = b }, function (t, e) { let r = 1; typeof window !== 'undefined' && (r = Math.max(window.devicePixelRatio || 1, 1)); const n = r; e.debugMode = 0, e.devicePixelRatio = n }, function (t, e, r) { function n (t) { return i(t), M(t.rich, i), t } function i (t) { if (t) { t.font = P.makeFont(t); let e = t.textAlign; e === 'middle' && (e = 'center'), t.textAlign = e == null || O[e] ? e : 'left'; let r = t.textVerticalAlign || t.textBaseline; r === 'center' && (r = 'middle'), t.textVerticalAlign = r == null || D[r] ? r : 'top'; t.textPadding && (t.textPadding = T(t.textPadding)) } } function a (t, e, r, n, i) { n.rich ? s(t, e, r, n, i) : o(t, e, r, n, i) } function o (t, e, r, n, i) { const a = g(e, 'font', n.font || P.DEFAULT_FONT); const o = n.textPadding; let s = t.__textCotentBlock; s && !t.__dirty || (s = t.__textCotentBlock = P.parsePlainText(r, a, o, n.truncate)); const l = s.outerHeight; const u = s.lines; const d = s.lineHeight; const x = v(l, n, i); const w = x.baseX; const _ = x.baseY; const b = x.textAlign; const S = x.textVerticalAlign; h(e, n, i, w, _); const M = P.adjustTextY(_, l, S); let T = w; let k = M; const C = c(n); if (C || o) { const I = P.getWidth(r, a); let A = I; o && (A += o[1] + o[3]); const O = P.adjustTextX(w, A, b); C && f(t, e, n, O, M, A, l), o && (T = y(w, b, o), k += o[0]) }g(e, 'textAlign', b || 'left'), g(e, 'textBaseline', 'middle'), g(e, 'shadowBlur', n.textShadowBlur || 0), g(e, 'shadowColor', n.textShadowColor || 'transparent'), g(e, 'shadowOffsetX', n.textShadowOffsetX || 0), g(e, 'shadowOffsetY', n.textShadowOffsetY || 0), k += d / 2; const D = n.textStrokeWidth; const L = p(n.textStroke, D); const F = m(n.textFill); L && (g(e, 'lineWidth', D), g(e, 'strokeStyle', L)), F && g(e, 'fillStyle', F); for (let R = 0; R < u.length; R++)L && e.strokeText(u[R], T, k), F && e.fillText(u[R], T, k), k += d } function s (t, e, r, n, i) { let a = t.__textCotentBlock; a && !t.__dirty || (a = t.__textCotentBlock = P.parseRichText(r, n)), l(t, e, a, n, i) } function l (t, e, r, n, i) { const a = r.width; const o = r.outerWidth; const s = r.outerHeight; const l = n.textPadding; const d = v(s, n, i); const g = d.baseX; const p = d.baseY; const m = d.textAlign; const x = d.textVerticalAlign; h(e, n, i, g, p); const y = P.adjustTextX(g, o, m); const w = P.adjustTextY(p, s, x); let _ = y; let b = w; l && (_ += l[3], b += l[0]); const S = _ + a; c(n) && f(t, e, n, y, w, o, s); for (let M = 0; M < r.lines.length; M++) { for (var T, k = r.lines[M], C = k.tokens, I = C.length, A = k.lineHeight, O = k.width, D = 0, L = _, F = S, R = I - 1; D < I && (T = C[D], !T.textAlign || T.textAlign === 'left');)u(t, e, T, n, A, b, L, 'left'), O -= T.width, L += T.width, D++; for (;R >= 0 && (T = C[R], T.textAlign === 'right');)u(t, e, T, n, A, b, F, 'right'), O -= T.width, F -= T.width, R--; for (L += (a - (L - _) - (S - F) - O) / 2; D <= R;)T = C[D], u(t, e, T, n, A, b, L + T.width / 2, 'center'), L += T.width, D++; b += A } } function h (t, e, r, n, i) { if (r && e.textRotation) { const a = e.textOrigin; a === 'center' ? (n = r.width / 2 + r.x, i = r.height / 2 + r.y) : a && (n = a[0] + r.x, i = a[1] + r.y), t.translate(n, i), t.rotate(-e.textRotation), t.translate(-n, -i) } } function u (t, e, r, n, i, a, o, s) { const l = n.rich[r.styleName] || {}; const h = r.textVerticalAlign; let u = a + i / 2; h === 'top' ? u = a + r.height / 2 : h === 'bottom' && (u = a + i - r.height / 2), !r.isLineHolder && c(l) && f(t, e, l, s === 'right' ? o - r.width : s === 'center' ? o - r.width / 2 : o, u - r.height / 2, r.width, r.height); const d = r.textPadding; d && (o = y(o, s, d), u -= r.height / 2 - d[2] - r.textHeight / 2), g(e, 'shadowBlur', S(l.textShadowBlur, n.textShadowBlur, 0)), g(e, 'shadowColor', l.textShadowColor || n.textShadowColor || 'transparent'), g(e, 'shadowOffsetX', S(l.textShadowOffsetX, n.textShadowOffsetX, 0)), g(e, 'shadowOffsetY', S(l.textShadowOffsetY, n.textShadowOffsetY, 0)), g(e, 'textAlign', s), g(e, 'textBaseline', 'middle'), g(e, 'font', r.font || P.DEFAULT_FONT); const v = p(l.textStroke || n.textStroke, w); const x = m(l.textFill || n.textFill); var w = b(l.textStrokeWidth, n.textStrokeWidth); v && (g(e, 'lineWidth', w), g(e, 'strokeStyle', v), e.strokeText(r.text, o, u)), x && (g(e, 'fillStyle', x), e.fillText(r.text, o, u)) } function c (t) { return t.textBackgroundColor || t.textBorderWidth && t.textBorderColor } function f (t, e, r, n, i, a, o) { const s = r.textBackgroundColor; const l = r.textBorderWidth; const h = r.textBorderColor; const u = k(s); if (g(e, 'shadowBlur', r.textBoxShadowBlur || 0), g(e, 'shadowColor', r.textBoxShadowColor || 'transparent'), g(e, 'shadowOffsetX', r.textBoxShadowOffsetX || 0), g(e, 'shadowOffsetY', r.textBoxShadowOffsetY || 0), u || l && h) { e.beginPath(); const c = r.textBorderRadius; c ? I.buildPath(e, { x: n, y: i, width: a, height: o, r: c }) : e.rect(n, i, a, o), e.closePath() } if (u)g(e, 'fillStyle', s), e.fill(); else if (C(s)) { let f = s.image; f = A.createOrUpdateImage(f, null, t, d, s), f && A.isImageReady(f) && e.drawImage(f, n, i, a, o) }l && h && (g(e, 'lineWidth', l), g(e, 'strokeStyle', h), e.stroke()) } function d (t, e) { e.image = t } function v (t, e, r) { let n = e.x || 0; let i = e.y || 0; let a = e.textAlign; let o = e.textVerticalAlign; if (r) { const s = e.textPosition; if (s instanceof Array)n = r.x + x(s[0], r.width), i = r.y + x(s[1], r.height); else { const l = P.adjustTextPositionOnRect(s, r, e.textDistance); n = l.x, i = l.y, a = a || l.textAlign, o = o || l.textVerticalAlign } const h = e.textOffset; h && (n += h[0], i += h[1]) } return { baseX: n, baseY: i, textAlign: a, textVerticalAlign: o } } function g (t, e, r) { return t[e] = r, t[e] } function p (t, e) { return t == null || e <= 0 || t === 'transparent' || t === 'none' ? null : t.image || t.colorStops ? '#000' : t } function m (t) { return t == null || t === 'none' ? null : t.image || t.colorStops ? '#000' : t } function x (t, e) { return typeof t === 'string' ? t.lastIndexOf('%') >= 0 ? parseFloat(t) / 100 * e : parseFloat(t) : t } function y (t, e, r) { return e === 'right' ? t - r[1] : e === 'center' ? t + r[3] / 2 - r[1] / 2 : t + r[3] } function w (t, e) { return t != null && (t || e.textBackgroundColor || e.textBorderWidth && e.textBorderColor || e.textPadding) } const _ = r(0); var b = _.retrieve2; var S = _.retrieve3; var M = _.each; var T = _.normalizeCssArray; var k = _.isString; var C = _.isObject; var P = r(5); var I = r(21); var A = r(10); var O = { left: 1, right: 1, center: 1 }; var D = { top: 1, bottom: 1, middle: 1 }; e.normalizeTextStyle = n, e.renderText = a, e.getStroke = p, e.getFill = m, e.needDrawText = w }, function (t, e) { function r (t, e) { let r; let n; let i; let a; let o = e.x; let s = e.y; let l = e.width; let h = e.height; const u = e.r; l < 0 && (o += l, l = -l), h < 0 && (s += h, h = -h), typeof u === 'number' ? r = n = i = a = u : u instanceof Array ? u.length === 1 ? r = n = i = a = u[0] : u.length === 2 ? (r = i = u[0], n = a = u[1]) : u.length === 3 ? (r = u[0], n = a = u[1], i = u[2]) : (r = u[0], n = u[1], i = u[2], a = u[3]) : r = n = i = a = 0; let c; r + n > l && (c = r + n, r *= l / c, n *= l / c), i + a > l && (c = i + a, i *= l / c, a *= l / c), n + i > h && (c = n + i, n *= h / c, i *= h / c), r + a > h && (c = r + a, r *= h / c, a *= h / c), t.moveTo(o + r, s), t.lineTo(o + l - n, s), n !== 0 && t.quadraticCurveTo(o + l, s, o + l, s + n), t.lineTo(o + l, s + h - i), i !== 0 && t.quadraticCurveTo(o + l, s + h, o + l - i, s + h), t.lineTo(o + a, s + h), a !== 0 && t.quadraticCurveTo(o, s + h, o, s + h - a), t.lineTo(o, s + r), r !== 0 && t.quadraticCurveTo(o, s, o + r, s) }e.buildPath = r }, function (t, e) { function r (t) { return t %= n, t < 0 && (t += n), t } var n = 2 * Math.PI; e.normalizeRadian = r }, function (t, e, r) { function n (t, e, r) { let n = e.points; const o = e.smooth; if (n && n.length >= 2) { if (o && o !== 'spline') { const s = a(n, o, r, e.smoothConstraint); t.moveTo(n[0][0], n[0][1]); for (var l = n.length, h = 0; h < (r ? l : l - 1); h++) { const u = s[2 * h]; const c = s[2 * h + 1]; const f = n[(h + 1) % l]; t.bezierCurveTo(u[0], u[1], c[0], c[1], f[0], f[1]) } } else { o === 'spline' && (n = i(n, r)), t.moveTo(n[0][0], n[0][1]); for (var h = 1, d = n.length; h < d; h++)t.lineTo(n[h][0], n[h][1]) }r && t.closePath() } } var i = r(66); var a = r(67); e.buildPath = n }, function (t, e) { const r = function (t) { this.colorStops = t || [] }; r.prototype = { constructor: r, addColorStop: function (t, e) { this.colorStops.push({ offset: t, color: e }) } }; const n = r; t.exports = n }, function (t, e, r) { t.exports = r(26) }, function (t, e, r) { function n (t) { for (var e = t.getContext('2d'), r = e.getImageData(0, 0, t.width, t.height), n = e.createImageData(r), i = 0, a = 0, o = 0; o < r.data.length; o += 4) { var s = r.data[o + 3]; if (s > 128) { var l = r.data[o] + r.data[o + 1] + r.data[o + 2]; i += l, ++a } } for (var h = i / a, o = 0; o < r.data.length; o += 4) { var l = r.data[o] + r.data[o + 1] + r.data[o + 2]; var s = r.data[o + 3]; s < 128 || l > h ? (n.data[o] = 0, n.data[o + 1] = 0, n.data[o + 2] = 0, n.data[o + 3] = 0) : (n.data[o] = 255, n.data[o + 1] = 255, n.data[o + 2] = 255, n.data[o + 3] = 255) }e.putImageData(n, 0, 0) } const i = r(7); const a = r(27); r(28), r(77); const o = r(78); if (!o.isSupported) throw new Error('Sorry your browser not support wordCloud'); i.registerLayout(function (t, e) { t.eachSeriesByType('wordCloud', function (r) { function s (t) { const e = t.detail.item; t.detail.drawn && r.layoutInstance.ondraw && (t.detail.drawn.gx += l.x / m, t.detail.drawn.gy += l.y / m, r.layoutInstance.ondraw(e[0], e[1], e[2], t.detail.drawn)) } var l = a.getLayoutRect(r.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }); const h = r.getData(); const u = document.createElement('canvas'); u.width = l.width, u.height = l.height; const c = u.getContext('2d'); const f = r.get('maskImage'); if (f) try { c.drawImage(f, 0, 0, u.width, u.height), n(u) } catch (t) { console.error('Invalid mask image'), console.error(t.toString()) } const d = r.get('sizeRange'); const v = r.get('rotationRange'); const g = h.getDataExtent('value'); const p = Math.PI / 180; var m = r.get('gridSize'); o(u, { list: h.mapArray('value', function (t, e) { const r = h.getItemModel(e); return [h.getName(e), r.get('textStyle.normal.textSize', !0) || i.number.linearMap(t, g, d), e] }).sort(function (t, e) { return e[1] - t[1] }), fontFamily: r.get('textStyle.normal.fontFamily') || r.get('textStyle.emphasis.fontFamily') || t.get('textStyle.fontFamily'), fontWeight: r.get('textStyle.normal.fontWeight') || r.get('textStyle.emphasis.fontWeight') || t.get('textStyle.fontWeight'), gridSize: m, ellipticity: l.height / l.width, minRotation: v[0] * p, maxRotation: v[1] * p, clearCanvas: !f, rotateRatio: 1, rotationStep: r.get('rotationStep') * p, drawOutOfBound: r.get('drawOutOfBound'), shuffle: !1, shape: r.get('shape') }), u.addEventListener('wordclouddrawn', s), r.layoutInstance && r.layoutInstance.dispose(), r.layoutInstance = { ondraw: null, dispose: function () { u.removeEventListener('wordclouddrawn', s), u.addEventListener('wordclouddrawn', function (t) { t.preventDefault() }) } } }) }), i.registerPreprocessor(function (t) { function e (t) { t && i.util.each(n, function (e) { t.hasOwnProperty(e) && (t['text' + i.format.capitalFirst(e)] = t[e]) }) } let r = (t || {}).series; !i.util.isArray(r) && (r = r ? [r] : []); var n = ['shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY']; i.util.each(r, function (t) { if (t && t.type === 'wordCloud') { const r = t.textStyle || {}; e(r.normal), e(r.emphasis) } }) }) }, function (t, e, r) { function n (t, e, r, n, i) { let a = 0; let o = 0; n == null && (n = 1 / 0), i == null && (i = 1 / 0); let s = 0; e.eachChild(function (l, h) { let u; let c; const f = l.position; const d = l.getBoundingRect(); const v = e.childAt(h + 1); const g = v && v.getBoundingRect(); if (t === 'horizontal') { const p = d.width + (g ? -g.x + d.x : 0); u = a + p, u > n || l.newline ? (a = 0, u = p, o += s + r, s = d.height) : s = Math.max(s, d.height) } else { const m = d.height + (g ? -g.y + d.y : 0); c = o + m, c > i || l.newline ? (a += s + r, o = 0, c = m, s = d.width) : s = Math.max(s, d.width) }l.newline || (f[0] = a, f[1] = o, t === 'horizontal' ? a = u + r : o = c + r) }) } function i (t, e, r) { const n = e.width; const i = e.height; let a = v(t.x, n); let o = v(t.y, i); let s = v(t.x2, n); let l = v(t.y2, i); return (isNaN(a) || isNaN(parseFloat(t.x))) && (a = 0), (isNaN(s) || isNaN(parseFloat(t.x2))) && (s = n), (isNaN(o) || isNaN(parseFloat(t.y))) && (o = 0), (isNaN(l) || isNaN(parseFloat(t.y2))) && (l = i), r = g.normalizeCssArray(r || 0), { width: Math.max(s - a - r[1] - r[3], 0), height: Math.max(l - o - r[0] - r[2], 0) } } function a (t, e, r) { r = g.normalizeCssArray(r || 0); const n = e.width; const i = e.height; let a = v(t.left, n); let o = v(t.top, i); const s = v(t.right, n); const l = v(t.bottom, i); let h = v(t.width, n); let u = v(t.height, i); const c = r[2] + r[0]; const d = r[1] + r[3]; const p = t.aspect; switch (isNaN(h) && (h = n - s - d - a), isNaN(u) && (u = i - l - c - o), p != null && (isNaN(h) && isNaN(u) && (p > n / i ? h = 0.8 * n : u = 0.8 * i), isNaN(h) && (h = p * u), isNaN(u) && (u = h / p)), isNaN(a) && (a = n - s - h - d), isNaN(o) && (o = i - l - u - c), t.left || t.right) { case 'center':a = n / 2 - h / 2 - r[3]; break; case 'right':a = n - h - d } switch (t.top || t.bottom) { case 'middle':case 'center':o = i / 2 - u / 2 - r[0]; break; case 'bottom':o = i - u - c }a = a || 0, o = o || 0, isNaN(h) && (h = n - d - a - (s || 0)), isNaN(u) && (u = i - c - o - (l || 0)); const m = new f(a + r[3], o + r[0], h, u); return m.margin = r, m } function o (t, e, r, n, i) { const o = !i || !i.hv || i.hv[0]; const s = !i || !i.hv || i.hv[1]; const l = i && i.boundingMode || 'all'; if (o || s) { let h; if (l === 'raw')h = t.type === 'group' ? new f(0, 0, +e.width || 0, +e.height || 0) : t.getBoundingRect(); else if (h = t.getBoundingRect(), t.needLocalTransform()) { const u = t.getLocalTransform(); h = h.clone(), h.applyTransform(u) }e = a(c.defaults({ width: h.width, height: h.height }, e), r, n); const d = t.position; const v = o ? e.x - h.x : 0; const g = s ? e.y - h.y : 0; t.attr('position', l === 'raw' ? [v, g] : [d[0] + v, d[1] + g]) } } function s (t, e) { return t[x[e][0]] != null || t[x[e][1]] != null && t[x[e][2]] != null } function l (t, e, r) { function n (r, n) { const o = {}; let l = 0; const h = {}; let u = 0; if (p(r, function (e) { h[e] = t[e] }), p(r, function (t) { i(e, t) && (o[t] = h[t] = e[t]), a(o, t) && l++, a(h, t) && u++ }), s[n]) return a(e, r[1]) ? h[r[2]] = null : a(e, r[2]) && (h[r[1]] = null), h; if (u !== 2 && l) { if (l >= 2) return o; for (let c = 0; c < r.length; c++) { const f = r[c]; if (!i(o, f) && i(t, f)) { o[f] = t[f]; break } } return o } return h } function i (t, e) { return t.hasOwnProperty(e) } function a (t, e) { return t[e] != null && t[e] !== 'auto' } function o (t, e, r) { p(t, function (t) { e[t] = r[t] }) }!c.isObject(r) && (r = {}); var s = r.ignoreSize; !c.isArray(s) && (s = [s, s]); const l = n(x[0], 0); const h = n(x[1], 1); o(x[0], t, l), o(x[1], t, h) } function h (t) { return u({}, t) } function u (t, e) { return e && t && p(m, function (r) { e.hasOwnProperty(r) && (t[r] = e[r]) }), t } var c = r(0); var f = r(3); const d = r(9); var v = d.parsePercent; var g = r(13); var p = c.each; var m = ['left', 'right', 'top', 'bottom', 'width', 'height']; var x = [['width', 'left', 'right'], ['height', 'top', 'bottom']]; const y = n; const w = c.curry(n, 'vertical'); const _ = c.curry(n, 'horizontal'); e.LOCATION_PARAMS = m, e.HV_NAMES = x, e.box = y, e.vbox = w, e.hbox = _, e.getAvailableSize = i, e.getLayoutRect = a, e.positionElement = o, e.sizeCalculable = s, e.mergeLayoutParam = l, e.getLayoutParams = h, e.copyLayoutParams = u }, function (t, e, r) { const n = r(29); const i = r(7); i.extendSeriesModel({ type: 'series.wordCloud', visualColorAccessPath: 'textStyle.normal.color', optionUpdated: function () { const t = this.option; t.gridSize = Math.max(Math.floor(t.gridSize), 4) }, getInitialData: function (t, e) { const r = n(['value'], t.data); const a = new i.List(r, this); return a.initData(t.data), a }, defaultOption: { maskImage: null, shape: 'circle', left: 'center', top: 'center', width: '70%', height: '80%', sizeRange: [12, 60], rotationRange: [-90, 90], rotationStep: 45, gridSize: 8, drawOutOfBound: !1, textStyle: { normal: { fontWeight: 'normal' } } } }) }, function (t, e, r) { function n (t, e, r) { function n (t, e, r) { c[e] ? t.otherDims[e] = r : (t.coordDim = e, t.coordDimIndex = r, p.set(e, !0)) } function o (t, e, r) { if (r || e.get(t) != null) { for (var n = 0; e.get(t + n) != null;)n++; t += n } return e.set(t, !0), t }e = e || [], r = r || {}, t = (t || []).slice(); const d = (r.dimsDef || []).slice(); const v = a.createHashMap(r.encodeDef); const g = a.createHashMap(); var p = a.createHashMap(); const m = []; let x = r.dimCount; if (x == null) { const y = i(e[0]); x = Math.max(a.isArray(y) && y.length || 1, t.length, d.length), l(t, function (t) { const e = t.dimsDef; e && (x = Math.max(x, e.length)) }) } for (let w = 0; w < x; w++) { const _ = h(d[w]) ? { name: d[w] } : d[w] || {}; const b = _.name; var S = m[w] = { otherDims: {} }; b != null && g.get(b) == null && (S.name = S.tooltipName = b, g.set(b, w)), _.type != null && (S.type = _.type) }v.each(function (t, e) { t = v.set(e, s(t).slice()), l(t, function (r, i) { h(r) && (r = g.get(r)), r != null && r < x && (t[i] = r, n(m[r], e, i)) }) }); let M = 0; l(t, function (t, e) { var r, t, i, o; h(t) ? (r = t, t = {}) : (r = t.name, t = a.clone(t), i = t.dimsDef, o = t.otherDims, t.name = t.coordDim = t.coordDimIndex = t.dimsDef = t.otherDims = null); const c = s(v.get(r)); if (!c.length) for (let f = 0; f < (i && i.length || 1); f++) { for (;M < m.length && m[M].coordDim != null;)M++; M < m.length && c.push(M++) }l(c, function (e, a) { const s = m[e]; n(u(s, t), r, a), s.name == null && i && (s.name = s.tooltipName = i[a]), o && u(s.otherDims, o) }) }); for (let T = r.extraPrefix || 'value', k = 0; k < x; k++) { var S = m[k] = m[k] || {}; S.coordDim == null && (S.coordDim = o(T, p, r.extraFromZero), S.coordDimIndex = 0, S.isExtraCoord = !0), S.name == null && (S.name = o(S.coordDim, g)), S.type == null && f(e, k) && (S.type = 'ordinal') } return m } function i (t) { return a.isArray(t) ? t : a.isObject(t) ? t.value : t } var a = r(0); const o = r(30); var s = o.normalizeToArray; var l = a.each; var h = a.isString; var u = a.defaults; var c = { tooltip: 1, label: 1, itemName: 1 }; var f = n.guessOrdinal = function (t, e) { for (let r = 0, n = t.length; r < n; r++) { var o = i(t[r]); if (!a.isArray(o)) return !1; var o = o[e]; if (o != null && isFinite(o) && o !== '') return !1; if (h(o) && o !== '-') return !0 } return !1 }; const d = n; t.exports = d }, function (t, e, r) { function n (t) { return t instanceof Array ? t : t == null ? [] : [t] } function i (t, e) { if (t) for (let r = t.emphasis = t.emphasis || {}, n = t.normal = t.normal || {}, i = 0, a = e.length; i < a; i++) { const o = e[i]; !r.hasOwnProperty(o) && n.hasOwnProperty(o) && (r[o] = n[o]) } } function a (t) { return t && (t.value == null ? t : t.value) } function o (t) { return M(t) && !(t instanceof Array) } function s (t, e) { const r = e && e.type; return r === 'ordinal' ? t : (r === 'time' && typeof t !== 'number' && t != null && t !== '-' && (t = +_.parseDate(t)), t == null || t === '' ? NaN : +t) } function l (t, e) { const r = new b(); return y.mixin(r, k), r.seriesIndex = e.seriesIndex, r.name = e.name || '', r.mainType = e.mainType, r.subType = e.subType, r.getData = function () { return t }, r } function h (t, e) { e = (e || []).slice(); const r = y.map(t || [], function (t, e) { return { exist: t } }); return S(e, function (t, n) { if (M(t)) { for (var i = 0; i < r.length; i++) if (!r[i].option && t.id != null && r[i].exist.id === t.id + '') return r[i].option = t, void (e[n] = null); for (var i = 0; i < r.length; i++) { const a = r[i].exist; if (!(r[i].option || a.id != null && t.id != null || t.name == null || c(t) || c(a) || a.name !== t.name + '')) return r[i].option = t, void (e[n] = null) } } }), S(e, function (t, e) { if (M(t)) { for (var n = 0; n < r.length; n++) { const i = r[n].exist; if (!r[n].option && !c(i) && t.id == null) { r[n].option = t; break } }n >= r.length && r.push({ option: t }) } }), r } function u (t) { const e = y.createHashMap(); S(t, function (t, r) { const n = t.exist; n && e.set(n.id, t) }), S(t, function (t, r) { const n = t.option; y.assert(!n || n.id == null || !e.get(n.id) || e.get(n.id) === t, 'id duplicates: ' + (n && n.id)), n && n.id != null && e.set(n.id, t), !t.keyInfo && (t.keyInfo = {}) }), S(t, function (t, r) { const n = t.exist; const i = t.option; const a = t.keyInfo; if (M(i)) { if (a.name = i.name != null ? i.name + '' : n ? n.name : '\0-', n)a.id = n.id; else if (i.id != null)a.id = i.id + ''; else { let o = 0; do { a.id = '\0' + a.name + '\0' + o++ } while (e.get(a.id)) }e.set(a.id, t) } }) } function c (t) { return M(t) && t.id && (t.id + '').indexOf('\0_ec_\0') === 0 } function f (t, e) { function r (t, e, r) { for (let i = 0, a = t.length; i < a; i++) for (let o = t[i].seriesId, s = n(t[i].dataIndex), l = r && r[o], h = 0, u = s.length; h < u; h++) { const c = s[h]; l && l[c] ? l[c] = null : (e[o] || (e[o] = {}))[c] = 1 } } function i (t, e) { const r = []; for (const n in t) if (t.hasOwnProperty(n) && t[n] != null) if (e)r.push(+n); else { const a = i(t[n], !0); a.length && r.push({ seriesId: n, dataIndex: a }) } return r } const a = {}; const o = {}; return r(t || [], a), r(e || [], o, a), [i(a), i(o)] } function d (t, e) { return e.dataIndexInside != null ? e.dataIndexInside : e.dataIndex != null ? y.isArray(e.dataIndex) ? y.map(e.dataIndex, function (e) { return t.indexOfRawIndex(e) }) : t.indexOfRawIndex(e.dataIndex) : e.name != null ? y.isArray(e.name) ? y.map(e.name, function (e) { return t.indexOfName(e) }) : t.indexOfName(e.name) : void 0 } function v (t, e, r) { if (y.isString(e)) { const n = {}; n[e + 'Index'] = 0, e = n } const i = r && r.defaultMainType; !i || x(e, i + 'Index') || x(e, i + 'Id') || x(e, i + 'Name') || (e[i + 'Index'] = 0); const a = {}; return S(e, function (n, i) { var n = e[i]; if (i === 'dataIndex' || i === 'dataIndexInside') return void (a[i] = n); const o = i.match(/^(\w+)(Index|Id|Name)$/) || []; const s = o[1]; const l = (o[2] || '').toLowerCase(); if (!(!s || !l || n == null || l === 'index' && n === 'none' || r && r.includeMainTypes && y.indexOf(r.includeMainTypes, s) < 0)) { const h = { mainType: s }; l === 'index' && n === 'all' || (h[l] = n); const u = t.queryComponents(h); a[s + 'Models'] = u, a[s + 'Model'] = u[0] } }), a } function g (t, e) { const r = t.dimensions; e = t.getDimension(e); for (let n = 0; n < r.length; n++) { const i = t.getDimensionInfo(r[n]); if (i.name === e) return i.coordDim } } function p (t, e) { const r = []; return S(t.dimensions, function (n) { const i = t.getDimensionInfo(n); i.coordDim === e && (r[i.coordDimIndex] = i.name) }), r } function m (t, e) { const r = []; return S(t.dimensions, function (n) { const i = t.getDimensionInfo(n); const a = i.otherDims; const o = a[e]; o != null && !1 !== o && (r[o] = i.name) }), r } function x (t, e) { return t && t.hasOwnProperty(e) } var y = r(0); const w = r(13); var _ = r(9); var b = r(31); var S = y.each; var M = y.isObject; const T = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; var k = { getDataParams: function (t, e) { const r = this.getData(e); const n = this.getRawValue(t, e); const i = r.getRawIndex(t); const a = r.getName(t, !0); const o = r.getRawDataItem(t); const s = r.getItemVisual(t, 'color'); return { componentType: this.mainType, componentSubType: this.subType, seriesType: this.mainType === 'series' ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: this.id, seriesName: this.name, name: a, dataIndex: i, data: o, dataType: e, value: n, color: s, marker: w.getTooltipMarker(s), $vars: ['seriesName', 'name', 'value'] } }, getFormattedLabel: function (t, e, r, n, i) { e = e || 'normal'; const a = this.getData(r); const o = a.getItemModel(t); const s = this.getDataParams(t, r); n != null && s.value instanceof Array && (s.value = s.value[n]); const l = o.get([i || 'label', e, 'formatter']); return typeof l === 'function' ? (s.status = e, l(s)) : typeof l === 'string' ? w.formatTpl(l, s) : void 0 }, getRawValue: function (t, e) { const r = this.getData(e); const n = r.getRawDataItem(t); if (n != null) return !M(n) || n instanceof Array ? n : n.value }, formatTooltip: y.noop }; const C = (function () { let t = 0; return function () { const e = '\0__ec_prop_getter_' + t++; return function (t) { return t[e] || (t[e] = {}) } } }()); e.normalizeToArray = n, e.defaultEmphasis = i, e.TEXT_STYLE_OPTIONS = T, e.getDataItemValue = a, e.isDataItemOption = o, e.converDataValue = s, e.createDataFormatModel = l, e.dataFormatMixin = k, e.mappingToExists = h, e.makeIdAndName = u, e.isIdInner = c, e.compressBatches = f, e.queryDataIndex = d, e.makeGetter = C, e.parseFinder = v, e.dataDimToCoordDim = g, e.coordDimToDataDim = p, e.otherDimToDataDim = m }, function (t, e, r) { function n (t, e, r) { this.parentModel = e, this.ecModel = r, this.option = t } function i (t, e, r) { for (let n = 0; n < e.length && (!e[n] || (t = t && typeof t === 'object' ? t[e[n]] : null) != null); n++);return t == null && r && (t = r.get(e)), t } function a (t, e) { const r = l.get(t, 'getParent'); return r ? r.call(t, e) : t.parentModel } const o = r(0); const s = r(15); var l = r(32); const h = r(35); const u = r(36); const c = r(37); const f = r(76); const d = o.mixin; n.prototype = { constructor: n, init: null, mergeOption: function (t) { o.merge(this.option, t, !0) }, get: function (t, e) { return t == null ? this.option : i(this.option, this.parsePath(t), !e && a(this, t)) }, getShallow: function (t, e) { const r = this.option; let n = r == null ? r : r[t]; const i = !e && a(this, t); return n == null && i && (n = i.getShallow(t)), n }, getModel: function (t, e) { let r; const o = t == null ? this.option : i(this.option, t = this.parsePath(t)); return e = e || (r = a(this, t)) && r.getModel(t), new n(o, e, this.ecModel) }, isEmpty: function () { return this.option == null }, restoreData: function () {}, clone: function () { return new (0, this.constructor)(o.clone(this.option)) }, setReadOnly: function (t) { l.setReadOnly(this, t) }, parsePath: function (t) { return typeof t === 'string' && (t = t.split('.')), t }, customizeGetParent: function (t) { l.set(this, 'getParent', t) }, isAnimationEnabled: function () { if (!s.node) { if (this.option.animation != null) return !!this.option.animation; if (this.parentModel) return this.parentModel.isAnimationEnabled() } } }, l.enableClassExtend(n), d(n, h), d(n, u), d(n, c), d(n, f); const v = n; t.exports = v }, function (t, e, r) { function n (t, e, r) { return t[m + e] = r } function i (t, e) { return t[m + e] } function a (t, e) { return t.hasOwnProperty(m + e) } function o (t) { const e = { main: '', sub: '' }; return t && (t = t.split(g), e.main = t[0] || '', e.sub = t[1] || ''), e } function s (t) { v.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal') } function l (t, e) { t.$constructor = t, t.extend = function (t) { const e = this; const r = function () { t.$constructor ? t.$constructor.apply(this, arguments) : e.apply(this, arguments) }; return v.extend(r.prototype, t), r.extend = this.extend, r.superCall = h, r.superApply = u, v.inherits(r, this), r.superClass = e, r } } function h (t, e) { const r = v.slice(arguments, 2); return this.superClass.prototype[e].apply(t, r) } function u (t, e, r) { return this.superClass.prototype[e].apply(t, r) } function c (t, e) { function r (t) { let e = n[t.main]; return e && e[p] || (e = n[t.main] = {}, e[p] = !0), e }e = e || {}; var n = {}; if (t.registerClass = function (t, e) { if (e) if (s(e), e = o(e), e.sub) { if (e.sub !== p) { const i = r(e); i[e.sub] = t } } else n[e.main] = t; return t }, t.getClass = function (t, e, r) { let i = n[t]; if (i && i[p] && (i = e ? i[e] : null), r && !i) throw new Error(e ? 'Component ' + t + '.' + (e || '') + ' not exists. Load it first.' : t + '.type should be specified.'); return i }, t.getClassesByMainType = function (t) { t = o(t); const e = []; const r = n[t.main]; return r && r[p] ? v.each(r, function (t, r) { r !== p && e.push(t) }) : e.push(r), e }, t.hasClass = function (t) { return t = o(t), !!n[t.main] }, t.getAllClassMainTypes = function () { const t = []; return v.each(n, function (e, r) { t.push(r) }), t }, t.hasSubTypes = function (t) { t = o(t); const e = n[t.main]; return e && e[p] }, t.parseClassType = o, e.registerWhenExtend) { const i = t.extend; i && (t.extend = function (e) { const r = i.call(this, e); return t.registerClass(r, e.type) }) } return t } function f (t, e) {} const d = r(33); var v = (d.__DEV__, r(0)); var g = '.'; var p = '___EC__COMPONENT__CONTAINER___'; var m = '\0ec_\0'; e.set = n, e.get = i, e.hasOwn = a, e.parseClassType = o, e.enableClassExtend = l, e.enableClassManagement = c, e.setReadOnly = f }, function (t, e, r) { (function (t) { let r; typeof window !== 'undefined' ? r = window.__DEV__ : void 0 !== t && (r = t.__DEV__), void 0 === r && (r = !0); const n = r; e.__DEV__ = n }).call(e, r(34)) }, function (t, e) { let r; r = (function () { return this }()); try { r = r || Function('return this')() || (0, eval)('this') } catch (t) { typeof window === 'object' && (r = window) }t.exports = r }, function (t, e, r) { const n = r(11); const i = n([['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]); const a = { getLineStyle: function (t) { const e = i(this, t); const r = this.getLineDash(e.lineWidth); return r && (e.lineDash = r), e }, getLineDash: function (t) { t == null && (t = 1); const e = this.get('type'); const r = Math.max(t, 2); const n = 4 * t; return e === 'solid' || e == null ? null : e === 'dashed' ? [n, n] : [r, r] } }; t.exports = a }, function (t, e, r) { const n = r(11); const i = n([['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']]); const a = { getAreaStyle: function (t, e) { return i(this, t, e) } }; t.exports = a }, function (t, e, r) { const n = r(5); const i = r(38); const a = ['textStyle', 'color']; const o = { getTextColor: function (t) { const e = this.ecModel; return this.getShallow('color') || (!t && e ? e.get(a) : null) }, getFont: function () { return i.getFont({ fontStyle: this.getShallow('fontStyle'), fontWeight: this.getShallow('fontWeight'), fontSize: this.getShallow('fontSize'), fontFamily: this.getShallow('fontFamily') }, this.ecModel) }, getTextRect: function (t) { return n.getBoundingRect(t, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('rich'), this.getShallow('truncateText')) } }; t.exports = o }, function (t, e, r) { function n (t) { return Z.extend(t) } function i (t, e) { return V.extendFromString(t, e) } function a (t, e, r, n) { const i = V.createFromString(t, e); const a = i.getBoundingRect(); return r && (n === 'center' && (r = s(r, a)), l(i, r)), i } function o (t, e, r) { var n = new K({ style: { image: t, x: e.x, y: e.y, width: e.width, height: e.height }, onload: function (t) { if (r === 'center') { const i = { width: t.width, height: t.height }; n.setStyle(s(e, i)) } } }); return n } function s (t, e) { let r; const n = e.width / e.height; let i = t.height * n; return i <= t.width ? r = t.height : (i = t.width, r = i / n), { x: t.x + t.width / 2 - i / 2, y: t.y + t.height / 2 - r / 2, width: i, height: r } } function l (t, e) { if (t.applyTransform) { const r = t.getBoundingRect(); const n = r.calculateTransform(e); t.applyTransform(n) } } function h (t) { const e = t.shape; const r = t.style.lineWidth; return vt(2 * e.x1) === vt(2 * e.x2) && (e.x1 = e.x2 = c(e.x1, r, !0)), vt(2 * e.y1) === vt(2 * e.y2) && (e.y1 = e.y2 = c(e.y1, r, !0)), t } function u (t) { const e = t.shape; const r = t.style.lineWidth; const n = e.x; const i = e.y; const a = e.width; const o = e.height; return e.x = c(e.x, r, !0), e.y = c(e.y, r, !0), e.width = Math.max(c(n + a, r, !1) - e.x, a === 0 ? 0 : 1), e.height = Math.max(c(i + o, r, !1) - e.y, o === 0 ? 0 : 1), t } function c (t, e, r) { const n = vt(2 * t); return (n + vt(e)) % 2 == 0 ? n / 2 : (n + (r ? 1 : -1)) / 2 } function f (t) { return t != null && t != 'none' } function d (t) { return typeof t === 'string' ? G.lift(t, -0.1) : t } function v (t) { if (t.__hoverStlDirty) { const e = t.style.stroke; const r = t.style.fill; const n = t.__hoverStl; n.fill = n.fill || (f(r) ? d(r) : null), n.stroke = n.stroke || (f(e) ? d(e) : null); const i = {}; for (const a in n)n[a] != null && (i[a] = t.style[a]); t.__normalStl = i, t.__hoverStlDirty = !1 } } function g (t) { if (!t.__isHover) { if (v(t), t.useHoverLayer)t.__zr && t.__zr.addHover(t, t.__hoverStl); else { const e = t.style; const r = e.insideRollbackOpt; r && L(e), e.extendFrom(t.__hoverStl), r && (D(e, e.insideOriginalTextPosition, r), e.textFill == null && (e.textFill = r.autoColor)), t.dirty(!1), t.z2 += 1 }t.__isHover = !0 } } function p (t) { if (t.__isHover) { const e = t.__normalStl; t.useHoverLayer ? t.__zr && t.__zr.removeHover(t) : (e && t.setStyle(e), t.z2 -= 1), t.__isHover = !1 } } function m (t) { t.type === 'group' ? t.traverse(function (t) { t.type !== 'group' && g(t) }) : g(t) } function x (t) { t.type === 'group' ? t.traverse(function (t) { t.type !== 'group' && p(t) }) : p(t) } function y (t, e) { t.__hoverStl = t.hoverStyle || e || {}, t.__hoverStlDirty = !0, t.__isHover && v(t) } function w (t) { this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && m(this) } function _ (t) { this.__hoverSilentOnTouch && t.zrByTouch || !this.__isEmphasis && x(this) } function b () { this.__isEmphasis = !0, m(this) } function S () { this.__isEmphasis = !1, x(this) } function M (t, e, r) { t.__hoverSilentOnTouch = r && r.hoverSilentOnTouch, t.type === 'group' ? t.traverse(function (t) { t.type !== 'group' && y(t, e) }) : y(t, e), t.on('mouseover', w).on('mouseout', _), t.on('emphasis', b).on('normal', S) } function T (t, e, r, n, i, a, o) { i = i || mt; const s = i.labelFetcher; const l = i.labelDataIndex; const h = i.labelDimIndex; const u = r.getShallow('show'); const c = n.getShallow('show'); const f = u || c ? Y.retrieve2(s ? s.getFormattedLabel(l, 'normal', null, h) : null, i.defaultText) : null; const d = u ? f : null; const v = c ? Y.retrieve2(s ? s.getFormattedLabel(l, 'emphasis', null, h) : null, f) : null; d == null && v == null || (k(t, r, a, i), k(e, n, o, i, !0)), t.text = d, e.text = v } function k (t, e, r, n, i) { return P(t, e, n, i), r && Y.extend(t, r), t.host && t.host.dirty && t.host.dirty(!1), t } function C (t, e, r) { let n; const i = { isRectText: !0 }; !1 === r ? n = !0 : i.autoColor = r, P(t, e, i, n), t.host && t.host.dirty && t.host.dirty(!1) } function P (t, e, r, n) { if (r = r || mt, r.isRectText) { let i = e.getShallow('position') || (n ? null : 'inside'); i === 'outside' && (i = 'top'), t.textPosition = i, t.textOffset = e.getShallow('offset'); let a = e.getShallow('rotate'); a != null && (a *= Math.PI / 180), t.textRotation = a, t.textDistance = Y.retrieve2(e.getShallow('distance'), n ? null : 5) } let o; const s = e.ecModel; const l = s && s.option.textStyle; const h = I(e); if (h) { o = {}; for (const u in h) if (h.hasOwnProperty(u)) { const c = e.getModel(['rich', u]); A(o[u] = {}, c, l, r, n) } } return t.rich = o, A(t, e, l, r, n, !0), r.forceRich && !r.textStyle && (r.textStyle = {}), t } function I (t) { for (var e; t && t !== t.ecModel;) { const r = (t.option || mt).rich; if (r) { e = e || {}; for (const n in r)r.hasOwnProperty(n) && (e[n] = 1) }t = t.parentModel } return e } function A (t, e, r, n, i, a) { if (r = !i && r || mt, t.textFill = O(e.getShallow('color'), n) || r.color, t.textStroke = O(e.getShallow('textBorderColor'), n) || r.textBorderColor, t.textStrokeWidth = Y.retrieve2(e.getShallow('textBorderWidth'), r.textBorderWidth), !i) { if (a) { const o = t.textPosition; t.insideRollback = D(t, o, n), t.insideOriginalTextPosition = o, t.insideRollbackOpt = n }t.textFill == null && (t.textFill = n.autoColor) }t.fontStyle = e.getShallow('fontStyle') || r.fontStyle, t.fontWeight = e.getShallow('fontWeight') || r.fontWeight, t.fontSize = e.getShallow('fontSize') || r.fontSize, t.fontFamily = e.getShallow('fontFamily') || r.fontFamily, t.textAlign = e.getShallow('align'), t.textVerticalAlign = e.getShallow('verticalAlign') || e.getShallow('baseline'), t.textLineHeight = e.getShallow('lineHeight'), t.textWidth = e.getShallow('width'), t.textHeight = e.getShallow('height'), t.textTag = e.getShallow('tag'), a && n.disableBox || (t.textBackgroundColor = O(e.getShallow('backgroundColor'), n), t.textPadding = e.getShallow('padding'), t.textBorderColor = O(e.getShallow('borderColor'), n), t.textBorderWidth = e.getShallow('borderWidth'), t.textBorderRadius = e.getShallow('borderRadius'), t.textBoxShadowColor = e.getShallow('shadowColor'), t.textBoxShadowBlur = e.getShallow('shadowBlur'), t.textBoxShadowOffsetX = e.getShallow('shadowOffsetX'), t.textBoxShadowOffsetY = e.getShallow('shadowOffsetY')), t.textShadowColor = e.getShallow('textShadowColor') || r.textShadowColor, t.textShadowBlur = e.getShallow('textShadowBlur') || r.textShadowBlur, t.textShadowOffsetX = e.getShallow('textShadowOffsetX') || r.textShadowOffsetX, t.textShadowOffsetY = e.getShallow('textShadowOffsetY') || r.textShadowOffsetY } function O (t, e) { return t !== 'auto' ? t : e && e.autoColor ? e.autoColor : null } function D (t, e, r) { let n; const i = r.useInsideStyle; return t.textFill == null && !1 !== i && (!0 === i || r.isRectText && e && typeof e === 'string' && e.indexOf('inside') >= 0) && (n = { textFill: null, textStroke: t.textStroke, textStrokeWidth: t.textStrokeWidth }, t.textFill = '#fff', t.textStroke == null && (t.textStroke = r.autoColor, t.textStrokeWidth == null && (t.textStrokeWidth = 2))), n } function L (t) { const e = t.insideRollback; e && (t.textFill = e.textFill, t.textStroke = e.textStroke, t.textStrokeWidth = e.textStrokeWidth) } function F (t, e) { const r = e || e.getModel('textStyle'); return [t.fontStyle || r && r.getShallow('fontStyle') || '', t.fontWeight || r && r.getShallow('fontWeight') || '', (t.fontSize || r && r.getShallow('fontSize') || 12) + 'px', t.fontFamily || r && r.getShallow('fontFamily') || 'sans-serif'].join(' ') } function R (t, e, r, n, i, a) { if (typeof i === 'function' && (a = i, i = null), n && n.isAnimationEnabled()) { const o = t ? 'Update' : ''; let s = n.getShallow('animationDuration' + o); const l = n.getShallow('animationEasing' + o); let h = n.getShallow('animationDelay' + o); typeof h === 'function' && (h = h(i, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, i) : null)), typeof s === 'function' && (s = s(i)), s > 0 ? e.animateTo(r, s, h || 0, l, a, !!a) : (e.stopAnimation(), e.attr(r), a && a()) } else e.stopAnimation(), e.attr(r), a && a() } function B (t, e, r, n, i) { R(!0, t, e, r, n, i) } function z (t, e, r, n, i) { R(!1, t, e, r, n, i) } function N (t, e) { for (var r = U.identity([]); t && t !== e;)U.mul(r, t.getLocalTransform(), r), t = t.parent; return r } function E (t, e, r) { return e && !Y.isArrayLike(e) && (e = Q.getLocalTransform(e)), r && (e = U.invert([], e)), $.applyTransform([], t, e) } function W (t, e, r) { const n = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]); const i = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]); let a = [t === 'left' ? -n : t === 'right' ? n : 0, t === 'top' ? -i : t === 'bottom' ? i : 0]; return a = E(a, e, r), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? 'right' : 'left' : a[1] > 0 ? 'bottom' : 'top' } function q (t, e, r, n) { function i (t) { const e = { position: $.clone(t.position), rotation: t.rotation }; return t.shape && (e.shape = Y.extend({}, t.shape)), e } if (t && e) { const a = (function (t) { const e = {}; return t.traverse(function (t) { !t.isGroup && t.anid && (e[t.anid] = t) }), e }(t)); e.traverse(function (t) { if (!t.isGroup && t.anid) { const e = a[t.anid]; if (e) { const n = i(t); t.attr(i(e)), B(t, n, r, t.dataIndex) } } }) } } function H (t, e) { return Y.map(t, function (t) { let r = t[0]; r = gt(r, e.x), r = pt(r, e.x + e.width); let n = t[1]; return n = gt(n, e.y), n = pt(n, e.y + e.height), [r, n] }) } function j (t, e) { const r = gt(t.x, e.x); const n = pt(t.x + t.width, e.x + e.width); const i = gt(t.y, e.y); const a = pt(t.y + t.height, e.y + e.height); if (n >= r && a >= i) return { x: r, y: i, width: n - r, height: a - i } } function X (t, e, r) { e = Y.extend({ rectHover: !0 }, e); const n = e.style = { strokeNoScale: !0 }; if (r = r || { x: -1, y: -1, width: 2, height: 2 }, t) return t.indexOf('image://') === 0 ? (n.image = t.slice(8), Y.defaults(n, r), new K(e)) : a(t.replace('path://', ''), e, r, 'center') } var Y = r(0); var V = r(39); var G = r(18); var U = r(8); var $ = r(2); var Z = r(1); var Q = r(17); var K = r(58); e.Image = K; const J = r(59); e.Group = J; const tt = r(60); e.Text = tt; const et = r(61); e.Circle = et; const rt = r(62); e.Sector = rt; const nt = r(64); e.Ring = nt; const it = r(65); e.Polygon = it; const at = r(68); e.Polyline = at; const ot = r(69); e.Rect = ot; const st = r(70); e.Line = st; const lt = r(71); e.BezierCurve = lt; const ht = r(72); e.Arc = ht; const ut = r(73); e.CompoundPath = ut; const ct = r(74); e.LinearGradient = ct; const ft = r(75); e.RadialGradient = ft; const dt = r(3); e.BoundingRect = dt; var vt = Math.round; var gt = Math.max; var pt = Math.min; var mt = {}; const xt = V.mergePath; e.extendShape = n, e.extendPath = i, e.makePath = a, e.makeImage = o, e.mergePath = xt, e.resizePath = l, e.subPixelOptimizeLine = h, e.subPixelOptimizeRect = u, e.subPixelOptimize = c, e.setHoverStyle = M, e.setLabelStyle = T, e.setTextStyle = k, e.setText = C, e.getFont = F, e.updateProps = B, e.initProps = z, e.getTransform = N, e.applyTransform = E, e.transformDirection = W, e.groupTransition = q, e.clipPointsByRect = H, e.clipRectByRect = j, e.createIcon = X }, function (t, e, r) { function n (t, e, r, n, i, a, o, s, l, h, u) { const c = l * (p / 180); const f = g(c) * (t - r) / 2 + v(c) * (e - n) / 2; const m = -1 * v(c) * (t - r) / 2 + g(c) * (e - n) / 2; const w = f * f / (o * o) + m * m / (s * s); w > 1 && (o *= d(w), s *= d(w)); const _ = (i === a ? -1 : 1) * d((o * o * (s * s) - o * o * (m * m) - s * s * (f * f)) / (o * o * (m * m) + s * s * (f * f))) || 0; const b = _ * o * m / s; const S = _ * -s * f / o; const M = (t + r) / 2 + g(c) * b - v(c) * S; const T = (e + n) / 2 + v(c) * b + g(c) * S; const k = y([1, 0], [(f - b) / o, (m - S) / s]); const C = [(f - b) / o, (m - S) / s]; const P = [(-1 * f - b) / o, (-1 * m - S) / s]; let I = y(C, P); x(C, P) <= -1 && (I = p), x(C, P) >= 1 && (I = 0), a === 0 && I > 0 && (I -= 2 * p), a === 1 && I < 0 && (I += 2 * p), u.addData(h, M, T, o, s, k, I, c, a) } function i (t) { if (!t) return []; let e; let r = t.replace(/-/g, ' -').replace(/ {2}/g, ' ').replace(/ /g, ',').replace(/,,/g, ','); for (e = 0; e < f.length; e++)r = r.replace(new RegExp(f[e], 'g'), '|' + f[e]); let i; const a = r.split('|'); let o = 0; let s = 0; const l = new u(); const h = u.CMD; for (e = 1; e < a.length; e++) { var c; const d = a[e]; let v = d.charAt(0); let g = 0; const p = d.slice(1).replace(/e,-/g, 'e-').split(','); p.length > 0 && p[0] === '' && p.shift(); for (let m = 0; m < p.length; m++)p[m] = parseFloat(p[m]); for (;g < p.length && !isNaN(p[g]) && !isNaN(p[0]);) { var x; var y; var w; var _; var b; var S; var M; let T = o; let k = s; switch (v) { case 'l':o += p[g++], s += p[g++], c = h.L, l.addData(c, o, s); break; case 'L':o = p[g++], s = p[g++], c = h.L, l.addData(c, o, s); break; case 'm':o += p[g++], s += p[g++], c = h.M, l.addData(c, o, s), v = 'l'; break; case 'M':o = p[g++], s = p[g++], c = h.M, l.addData(c, o, s), v = 'L'; break; case 'h':o += p[g++], c = h.L, l.addData(c, o, s); break; case 'H':o = p[g++], c = h.L, l.addData(c, o, s); break; case 'v':s += p[g++], c = h.L, l.addData(c, o, s); break; case 'V':s = p[g++], c = h.L, l.addData(c, o, s); break; case 'C':c = h.C, l.addData(c, p[g++], p[g++], p[g++], p[g++], p[g++], p[g++]), o = p[g - 2], s = p[g - 1]; break; case 'c':c = h.C, l.addData(c, p[g++] + o, p[g++] + s, p[g++] + o, p[g++] + s, p[g++] + o, p[g++] + s), o += p[g - 2], s += p[g - 1]; break; case 'S':x = o, y = s; var C = l.len(); var P = l.data; i === h.C && (x += o - P[C - 4], y += s - P[C - 3]), c = h.C, T = p[g++], k = p[g++], o = p[g++], s = p[g++], l.addData(c, x, y, T, k, o, s); break; case 's':x = o, y = s; var C = l.len(); var P = l.data; i === h.C && (x += o - P[C - 4], y += s - P[C - 3]), c = h.C, T = o + p[g++], k = s + p[g++], o += p[g++], s += p[g++], l.addData(c, x, y, T, k, o, s); break; case 'Q':T = p[g++], k = p[g++], o = p[g++], s = p[g++], c = h.Q, l.addData(c, T, k, o, s); break; case 'q':T = p[g++] + o, k = p[g++] + s, o += p[g++], s += p[g++], c = h.Q, l.addData(c, T, k, o, s); break; case 'T':x = o, y = s; var C = l.len(); var P = l.data; i === h.Q && (x += o - P[C - 4], y += s - P[C - 3]), o = p[g++], s = p[g++], c = h.Q, l.addData(c, x, y, o, s); break; case 't':x = o, y = s; var C = l.len(); var P = l.data; i === h.Q && (x += o - P[C - 4], y += s - P[C - 3]), o += p[g++], s += p[g++], c = h.Q, l.addData(c, x, y, o, s); break; case 'A':w = p[g++], _ = p[g++], b = p[g++], S = p[g++], M = p[g++], T = o, k = s, o = p[g++], s = p[g++], c = h.A, n(T, k, o, s, S, M, w, _, b, c, l); break; case 'a':w = p[g++], _ = p[g++], b = p[g++], S = p[g++], M = p[g++], T = o, k = s, o += p[g++], s += p[g++], c = h.A, n(T, k, o, s, S, M, w, _, b, c, l) } }v !== 'z' && v !== 'Z' || (c = h.Z, l.addData(c)), i = c } return l.toStatic(), l } function a (t, e) { const r = i(t); return e = e || {}, e.buildPath = function (t) { if (t.setData) { t.setData(r.data); var e = t.getContext(); e && t.rebuildPath(e) } else { var e = t; r.rebuildPath(e) } }, e.applyTransform = function (t) { c(r, t), this.dirty(!0) }, e } function o (t, e) { return new h(a(t, e)) } function s (t, e) { return h.extend(a(t, e)) } function l (t, e) { for (var r = [], n = t.length, i = 0; i < n; i++) { const a = t[i]; a.path || a.createPathProxy(), a.__dirtyPath && a.buildPath(a.path, a.shape, !0), r.push(a.path) } const o = new h(e); return o.createPathProxy(), o.buildPath = function (t) { t.appendPath(r); const e = t.getContext(); e && t.rebuildPath(e) }, o } var h = r(1); var u = r(6); var c = r(57); var f = ['m', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z', 'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A']; var d = Math.sqrt; var v = Math.sin; var g = Math.cos; var p = Math.PI; const m = function (t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) }; var x = function (t, e) { return (t[0] * e[0] + t[1] * e[1]) / (m(t) * m(e)) }; var y = function (t, e) { return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(x(t, e)) }; e.createFromString = o, e.extendFromString = s, e.mergePath = l }, function (t, e) { function r (t, e, r) { let n = e.x == null ? 0 : e.x; let i = e.x2 == null ? 1 : e.x2; let a = e.y == null ? 0 : e.y; let o = e.y2 == null ? 0 : e.y2; return e.global || (n = n * r.width + r.x, i = i * r.width + r.x, a = a * r.height + r.y, o = o * r.height + r.y), t.createLinearGradient(n, a, i, o) } function n (t, e, r) { const n = r.width; const i = r.height; const a = Math.min(n, i); let o = e.x == null ? 0.5 : e.x; let s = e.y == null ? 0.5 : e.y; let l = e.r == null ? 0.5 : e.r; return e.global || (o = o * n + r.x, s = s * i + r.y, l *= a), t.createRadialGradient(o, s, 0, o, s, l) } const i = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; const a = function (t, e) { this.extendFrom(t, !1), this.host = e }; a.prototype = { constructor: a, host: null, fill: '#000', stroke: null, opacity: 1, lineDash: null, lineDashOffset: 0, shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, lineWidth: 1, strokeNoScale: !1, text: null, font: null, textFont: null, fontStyle: null, fontWeight: null, fontSize: null, fontFamily: null, textTag: null, textFill: '#000', textStroke: null, textWidth: null, textHeight: null, textStrokeWidth: 0, textLineHeight: null, textPosition: 'inside', textRect: null, textOffset: null, textAlign: null, textVerticalAlign: null, textDistance: 5, textShadowColor: 'transparent', textShadowBlur: 0, textShadowOffsetX: 0, textShadowOffsetY: 0, textBoxShadowColor: 'transparent', textBoxShadowBlur: 0, textBoxShadowOffsetX: 0, textBoxShadowOffsetY: 0, transformText: !1, textRotation: 0, textOrigin: null, textBackgroundColor: null, textBorderColor: null, textBorderWidth: 0, textBorderRadius: 0, textPadding: null, rich: null, truncate: null, blend: null, bind: function (t, e, r) { for (var n = this, a = r && r.style, o = !a, s = 0; s < i.length; s++) { const l = i[s]; const h = l[0]; (o || n[h] !== a[h]) && (t[h] = n[h] || l[1]) } if ((o || n.fill !== a.fill) && (t.fillStyle = n.fill), (o || n.stroke !== a.stroke) && (t.strokeStyle = n.stroke), (o || n.opacity !== a.opacity) && (t.globalAlpha = n.opacity == null ? 1 : n.opacity), (o || n.blend !== a.blend) && (t.globalCompositeOperation = n.blend || 'source-over'), this.hasStroke()) { const u = n.lineWidth; t.lineWidth = u / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1) } }, hasFill: function () { const t = this.fill; return t != null && t !== 'none' }, hasStroke: function () { const t = this.stroke; return t != null && t !== 'none' && this.lineWidth > 0 }, extendFrom: function (t, e) { if (t) for (const r in t)!t.hasOwnProperty(r) || !0 !== e && (!1 === e ? this.hasOwnProperty(r) : t[r] == null) || (this[r] = t[r]) }, set: function (t, e) { typeof t === 'string' ? this[t] = e : this.extendFrom(t, !0) }, clone: function () { const t = new this.constructor(); return t.extendFrom(this, !0), t }, getGradient: function (t, e, i) { for (var a = e.type === 'radial' ? n : r, o = a(t, e, i), s = e.colorStops, l = 0; l < s.length; l++)o.addColorStop(s[l].offset, s[l].color); return o } }; for (var o = a.prototype, s = 0; s < i.length; s++) { const l = i[s]; l[0] in o || (o[l[0]] = l[1]) }a.getGradient = o.getGradient; const h = a; t.exports = h }, function (t, e) { function r () { return n++ } var n = 2311; t.exports = r }, function (t, e) { const r = Array.prototype.slice; const n = function () { this._$handlers = {} }; n.prototype = { constructor: n, one: function (t, e, r) { const n = this._$handlers; if (!e || !t) return this; n[t] || (n[t] = []); for (let i = 0; i < n[t].length; i++) if (n[t][i].h === e) return this; return n[t].push({ h: e, one: !0, ctx: r || this }), this }, on: function (t, e, r) { const n = this._$handlers; if (!e || !t) return this; n[t] || (n[t] = []); for (let i = 0; i < n[t].length; i++) if (n[t][i].h === e) return this; return n[t].push({ h: e, one: !1, ctx: r || this }), this }, isSilent: function (t) { const e = this._$handlers; return e[t] && e[t].length }, off: function (t, e) { const r = this._$handlers; if (!t) return this._$handlers = {}, this; if (e) { if (r[t]) { for (var n = [], i = 0, a = r[t].length; i < a; i++)r[t][i].h != e && n.push(r[t][i]); r[t] = n }r[t] && r[t].length === 0 && delete r[t] } else delete r[t]; return this }, trigger: function (t) { if (this._$handlers[t]) { let e = arguments; const n = e.length; n > 3 && (e = r.call(e, 1)); for (let i = this._$handlers[t], a = i.length, o = 0; o < a;) { switch (n) { case 1:i[o].h.call(i[o].ctx); break; case 2:i[o].h.call(i[o].ctx, e[1]); break; case 3:i[o].h.call(i[o].ctx, e[1], e[2]); break; default:i[o].h.apply(i[o].ctx, e) }i[o].one ? (i.splice(o, 1), a--) : o++ } } return this }, triggerWithContext: function (t) { if (this._$handlers[t]) { let e = arguments; const n = e.length; n > 4 && (e = r.call(e, 1, e.length - 1)); for (let i = e[e.length - 1], a = this._$handlers[t], o = a.length, s = 0; s < o;) { switch (n) { case 1:a[s].h.call(i); break; case 2:a[s].h.call(i, e[1]); break; case 3:a[s].h.call(i, e[1], e[2]); break; default:a[s].h.apply(i, e) }a[s].one ? (a.splice(s, 1), o--) : s++ } } return this } }; const i = n; t.exports = i }, function (t, e, r) { const n = r(44); const i = r(47); const a = r(0); const o = a.isString; const s = a.isFunction; const l = a.isObject; const h = a.isArrayLike; const u = a.indexOf; const c = function () { this.animators = [] }; c.prototype = { constructor: c, animate: function (t, e) { let r; let a = !1; const o = this; const s = this.__zr; if (t) { const l = t.split('.'); let h = o; a = l[0] === 'shape'; for (let c = 0, f = l.length; c < f; c++)h && (h = h[l[c]]); h && (r = h) } else r = o; if (!r) return void i('Property "' + t + '" is not existed in element ' + o.id); const d = o.animators; const v = new n(r, e); return v.during(function (t) { o.dirty(a) }).done(function () { d.splice(u(d, v), 1) }), d.push(v), s && s.animation.addAnimator(v), v }, stopAnimation: function (t) { for (var e = this.animators, r = e.length, n = 0; n < r; n++)e[n].stop(t); return e.length = 0, this }, animateTo: function (t, e, r, n, i, a) { function l () { --u || i && i() }o(r) ? (i = n, n = r, r = 0) : s(n) ? (i = n, n = 'linear', r = 0) : s(r) ? (i = r, r = 0) : s(e) ? (i = e, e = 500) : e || (e = 500), this.stopAnimation(), this._animateToShallow('', this, t, e, r); const h = this.animators.slice(); var u = h.length; u || i && i(); for (let c = 0; c < h.length; c++)h[c].done(l).start(n, a) }, _animateToShallow: function (t, e, r, n, i) { const a = {}; let o = 0; for (const s in r) if (r.hasOwnProperty(s)) if (e[s] != null)l(r[s]) && !h(r[s]) ? this._animateToShallow(t ? t + '.' + s : s, e[s], r[s], n, i) : (a[s] = r[s], o++); else if (r[s] != null) if (t) { const u = {}; u[t] = {}, u[t][s] = r[s], this.attr(u) } else this.attr(s, r[s]); return o > 0 && this.animate(t, !1).when(n == null ? 500 : n, a).delay(i || 0), this } }; const f = c; t.exports = f }, function (t, e, r) { function n (t, e) { return t[e] } function i (t, e, r) { t[e] = r } function a (t, e, r) { return (e - t) * r + t } function o (t, e, r) { return r > 0.5 ? e : t } function s (t, e, r, n, i) { const o = t.length; if (i == 1) for (var s = 0; s < o; s++)n[s] = a(t[s], e[s], r); else for (var l = o && t[0].length, s = 0; s < o; s++) for (let h = 0; h < l; h++)n[s][h] = a(t[s][h], e[s][h], r) } function l (t, e, r) { const n = t.length; const i = e.length; if (n !== i) { if (n > i)t.length = i; else for (var a = n; a < i; a++)t.push(r === 1 ? e[a] : w.call(e[a])) } for (var o = t[0] && t[0].length, a = 0; a < t.length; a++) if (r === 1)isNaN(t[a]) && (t[a] = e[a]); else for (let s = 0; s < o; s++)isNaN(t[a][s]) && (t[a][s] = e[a][s]) } function h (t, e, r) { if (t === e) return !0; const n = t.length; if (n !== e.length) return !1; if (r === 1) { for (var i = 0; i < n; i++) if (t[i] !== e[i]) return !1 } else for (var a = t[0].length, i = 0; i < n; i++) for (let o = 0; o < a; o++) if (t[i][o] !== e[i][o]) return !1; return !0 } function u (t, e, r, n, i, a, o, s, l) { const h = t.length; if (l == 1) for (var u = 0; u < h; u++)s[u] = c(t[u], e[u], r[u], n[u], i, a, o); else for (var f = t[0].length, u = 0; u < h; u++) for (let d = 0; d < f; d++)s[u][d] = c(t[u][d], e[u][d], r[u][d], n[u][d], i, a, o) } function c (t, e, r, n, i, a, o) { const s = 0.5 * (r - t); const l = 0.5 * (n - e); return (2 * (e - r) + s + l) * o + (-3 * (e - r) - 2 * s - l) * a + s * i + e } function f (t) { if (y(t)) { const e = t.length; if (y(t[0])) { for (var r = [], n = 0; n < e; n++)r.push(w.call(t[n])); return r } return w.call(t) } return t } function d (t) { return t[0] = Math.floor(t[0]), t[1] = Math.floor(t[1]), t[2] = Math.floor(t[2]), 'rgba(' + t.join(',') + ')' } function v (t) { const e = t[t.length - 1].value; return y(e && e[0]) ? 2 : 1 } function g (t, e, r, n, i, f) { const g = t._getter; const x = t._setter; const w = e === 'spline'; const _ = n.length; if (_) { let b; const S = n[0].value; const M = y(S); let T = !1; let k = !1; const C = M ? v(n) : 0; n.sort(function (t, e) { return t.time - e.time }), b = n[_ - 1].time; for (var P = [], I = [], A = n[0].value, O = !0, D = 0; D < _; D++) { P.push(n[D].time / b); let L = n[D].value; if (M && h(L, A, C) || !M && L === A || (O = !1), A = L, typeof L === 'string') { const F = m.parse(L); F ? (L = F, T = !0) : k = !0 }I.push(L) } if (f || !O) { for (var R = I[_ - 1], D = 0; D < _ - 1; D++)M ? l(I[D], R, C) : !isNaN(I[D]) || isNaN(R) || k || T || (I[D] = R); M && l(g(t._target, i), R, C); let B; let z; let N; let E; let W; let q; let H = 0; let j = 0; if (T) var X = [0, 0, 0, 0]; const Y = function (t, e) { let r; if (e < 0)r = 0; else if (e < j) { for (B = Math.min(H + 1, _ - 1), r = B; r >= 0 && !(P[r] <= e); r--);r = Math.min(r, _ - 2) } else { for (r = H; r < _ && !(P[r] > e); r++);r = Math.min(r - 1, _ - 2) }H = r, j = e; const n = P[r + 1] - P[r]; if (n !== 0) if (z = (e - P[r]) / n, w) if (E = I[r], N = I[r === 0 ? r : r - 1], W = I[r > _ - 2 ? _ - 1 : r + 1], q = I[r > _ - 3 ? _ - 1 : r + 2], M)u(N, E, W, q, z, z * z, z * z * z, g(t, i), C); else { var l; if (T)l = u(N, E, W, q, z, z * z, z * z * z, X, 1), l = d(X); else { if (k) return o(E, W, z); l = c(N, E, W, q, z, z * z, z * z * z) }x(t, i, l) } else if (M)s(I[r], I[r + 1], z, g(t, i), C); else { var l; if (T)s(I[r], I[r + 1], z, X, 1), l = d(X); else { if (k) return o(I[r], I[r + 1], z); l = a(I[r], I[r + 1], z) }x(t, i, l) } }; const V = new p({ target: t._target, life: b, loop: t._loop, delay: t._delay, onframe: Y, ondestroy: r }); return e && e !== 'spline' && (V.easing = e), V } } } var p = r(45); var m = r(18); const x = r(0); var y = x.isArrayLike; var w = Array.prototype.slice; const _ = function (t, e, r, a) { this._tracks = {}, this._target = t, this._loop = e || !1, this._getter = r || n, this._setter = a || i, this._clipCount = 0, this._delay = 0, this._doneList = [], this._onframeList = [], this._clipList = [] }; _.prototype = { when: function (t, e) { const r = this._tracks; for (const n in e) if (e.hasOwnProperty(n)) { if (!r[n]) { r[n] = []; const i = this._getter(this._target, n); if (i == null) continue; t !== 0 && r[n].push({ time: 0, value: f(i) }) }r[n].push({ time: t, value: e[n] }) } return this }, during: function (t) { return this._onframeList.push(t), this }, pause: function () { for (let t = 0; t < this._clipList.length; t++) this._clipList[t].pause(); this._paused = !0 }, resume: function () { for (let t = 0; t < this._clipList.length; t++) this._clipList[t].resume(); this._paused = !1 }, isPaused: function () { return !!this._paused }, _doneCallback: function () { this._tracks = {}, this._clipList.length = 0; for (let t = this._doneList, e = t.length, r = 0; r < e; r++)t[r].call(this) }, start: function (t, e) { let r; const n = this; let i = 0; const a = function () { --i || n._doneCallback() }; for (const o in this._tracks) if (this._tracks.hasOwnProperty(o)) { const s = g(this, t, a, this._tracks[o], o, e); s && (this._clipList.push(s), i++, this.animation && this.animation.addClip(s), r = s) } if (r) { const l = r.onframe; r.onframe = function (t, e) { l(t, e); for (let r = 0; r < n._onframeList.length; r++)n._onframeList[r](t, e) } } return i || this._doneCallback(), this }, stop: function (t) { for (var e = this._clipList, r = this.animation, n = 0; n < e.length; n++) { const i = e[n]; t && i.onframe(this._target, 1), r && r.removeClip(i) }e.length = 0 }, delay: function (t) { return this._delay = t, this }, done: function (t) { return t && this._doneList.push(t), this }, getClips: function () { return this._clipList } }; const b = _; t.exports = b }, function (t, e, r) { function n (t) { this._target = t.target, this._life = t.life || 1e3, this._delay = t.delay || 0, this._initialized = !1, this.loop = t.loop != null && t.loop, this.gap = t.gap || 0, this.easing = t.easing || 'Linear', this.onframe = t.onframe, this.ondestroy = t.ondestroy, this.onrestart = t.onrestart, this._pausedTime = 0, this._paused = !1 } const i = r(46); n.prototype = { constructor: n, step: function (t, e) { if (this._initialized || (this._startTime = t + this._delay, this._initialized = !0), this._paused) return void (this._pausedTime += e); let r = (t - this._startTime - this._pausedTime) / this._life; if (!(r < 0)) { r = Math.min(r, 1); const n = this.easing; const a = typeof n === 'string' ? i[n] : n; const o = typeof a === 'function' ? a(r) : r; return this.fire('frame', o), r == 1 ? this.loop ? (this.restart(t), 'restart') : (this._needsRemove = !0, 'destroy') : null } }, restart: function (t) { const e = (t - this._startTime - this._pausedTime) % this._life; this._startTime = t - e + this.gap, this._pausedTime = 0, this._needsRemove = !1 }, fire: function (t, e) { t = 'on' + t, this[t] && this[t](this._target, e) }, pause: function () { this._paused = !0 }, resume: function () { this._paused = !1 } }; const a = n; t.exports = a }, function (t, e) { var r = { linear: function (t) { return t }, quadraticIn: function (t) { return t * t }, quadraticOut: function (t) { return t * (2 - t) }, quadraticInOut: function (t) { return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1) }, cubicIn: function (t) { return t * t * t }, cubicOut: function (t) { return --t * t * t + 1 }, cubicInOut: function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2) }, quarticIn: function (t) { return t * t * t * t }, quarticOut: function (t) { return 1 - --t * t * t * t }, quarticInOut: function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2) }, quinticIn: function (t) { return t * t * t * t * t }, quinticOut: function (t) { return --t * t * t * t * t + 1 }, quinticInOut: function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2) }, sinusoidalIn: function (t) { return 1 - Math.cos(t * Math.PI / 2) }, sinusoidalOut: function (t) { return Math.sin(t * Math.PI / 2) }, sinusoidalInOut: function (t) { return 0.5 * (1 - Math.cos(Math.PI * t)) }, exponentialIn: function (t) { return t === 0 ? 0 : Math.pow(1024, t - 1) }, exponentialOut: function (t) { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t) }, exponentialInOut: function (t) { return t === 0 ? 0 : t === 1 ? 1 : (t *= 2) < 1 ? 0.5 * Math.pow(1024, t - 1) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))) }, circularIn: function (t) { return 1 - Math.sqrt(1 - t * t) }, circularOut: function (t) { return Math.sqrt(1 - --t * t) }, circularInOut: function (t) { return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) }, elasticIn: function (t) { let e; let r = 0.1; return t === 0 ? 0 : t === 1 ? 1 : (!r || r < 1 ? (r = 1, e = 0.1) : e = 0.4 * Math.asin(1 / r) / (2 * Math.PI), -r * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / 0.4)) }, elasticOut: function (t) { let e; let r = 0.1; return t === 0 ? 0 : t === 1 ? 1 : (!r || r < 1 ? (r = 1, e = 0.1) : e = 0.4 * Math.asin(1 / r) / (2 * Math.PI), r * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / 0.4) + 1) }, elasticInOut: function (t) { let e; let r = 0.1; return t === 0 ? 0 : t === 1 ? 1 : (!r || r < 1 ? (r = 1, e = 0.1) : e = 0.4 * Math.asin(1 / r) / (2 * Math.PI), (t *= 2) < 1 ? r * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / 0.4) * -0.5 : r * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / 0.4) * 0.5 + 1) }, backIn: function (t) { const e = 1.70158; return t * t * ((e + 1) * t - e) }, backOut: function (t) { const e = 1.70158; return --t * t * ((e + 1) * t + e) + 1 }, backInOut: function (t) { const e = 2.5949095; return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * 0.5 : 0.5 * ((t -= 2) * t * ((e + 1) * t + e) + 2) }, bounceIn: function (t) { return 1 - r.bounceOut(1 - t) }, bounceOut: function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375 }, bounceInOut: function (t) { return t < 0.5 ? 0.5 * r.bounceIn(2 * t) : 0.5 * r.bounceOut(2 * t - 1) + 0.5 } }; const n = r; t.exports = n }, function (t, e, r) { const n = r(19); const i = n.debugMode; let a = function () {}; i === 1 ? a = function () { for (const t in arguments) throw new Error(arguments[t]) } : i > 1 && (a = function () { for (const t in arguments)console.log(arguments[t]) }); const o = a; t.exports = o }, function (t, e, r) { const n = r(20); const i = r(3); const a = new i(); const o = function () {}; o.prototype = { constructor: o, drawRectText: function (t, e) { const r = this.style; e = r.textRect || e, this.__dirty && n.normalizeTextStyle(r, !0); let i = r.text; if (i != null && (i += ''), n.needDrawText(i, r)) { t.save(); const o = this.transform; r.transformText ? this.setTransform(t) : o && (a.copy(e), a.applyTransform(o), e = a), n.renderText(this, t, i, r, e), t.restore() } } }; const s = o; t.exports = s }, function (t, e, r) { function n (t, e, r) { if (t.length !== 0) { let n; let i = t[0]; let a = i[0]; let o = i[0]; let s = i[1]; let l = i[1]; for (n = 1; n < t.length; n++)i = t[n], a = u(a, i[0]), o = c(o, i[0]), s = u(s, i[1]), l = c(l, i[1]); e[0] = a, e[1] = s, r[0] = o, r[1] = l } } function i (t, e, r, n, i, a) { i[0] = u(t, r), i[1] = u(e, n), a[0] = c(t, r), a[1] = c(e, n) } function a (t, e, r, n, i, a, o, s, l, f) { let d; const v = h.cubicExtrema; const g = h.cubicAt; let p = v(t, r, i, o, x); for (l[0] = 1 / 0, l[1] = 1 / 0, f[0] = -1 / 0, f[1] = -1 / 0, d = 0; d < p; d++) { const m = g(t, r, i, o, x[d]); l[0] = u(m, l[0]), f[0] = c(m, f[0]) } for (p = v(e, n, a, s, y), d = 0; d < p; d++) { const w = g(e, n, a, s, y[d]); l[1] = u(w, l[1]), f[1] = c(w, f[1]) }l[0] = u(t, l[0]), f[0] = c(t, f[0]), l[0] = u(o, l[0]), f[0] = c(o, f[0]), l[1] = u(e, l[1]), f[1] = c(e, f[1]), l[1] = u(s, l[1]), f[1] = c(s, f[1]) } function o (t, e, r, n, i, a, o, s) { const l = h.quadraticExtremum; const f = h.quadraticAt; const d = c(u(l(t, r, i), 1), 0); const v = c(u(l(e, n, a), 1), 0); const g = f(t, r, i, d); const p = f(e, n, a, v); o[0] = u(t, i, g), o[1] = u(e, a, p), s[0] = c(t, i, g), s[1] = c(e, a, p) } function s (t, e, r, n, i, a, o, s, h) { const u = l.min; const c = l.max; const x = Math.abs(i - a); if (x % v < 1e-4 && x > 1e-4) return s[0] = t - r, s[1] = e - n, h[0] = t + r, void (h[1] = e + n); if (g[0] = d(i) * r + t, g[1] = f(i) * n + e, p[0] = d(a) * r + t, p[1] = f(a) * n + e, u(s, g, p), c(h, g, p), i %= v, i < 0 && (i += v), a %= v, a < 0 && (a += v), i > a && !o ? a += v : i < a && o && (i += v), o) { const y = a; a = i, i = y } for (let w = 0; w < a; w += Math.PI / 2)w > i && (m[0] = d(w) * r + t, m[1] = f(w) * n + e, u(s, m, s), c(h, m, h)) } var l = r(2); var h = r(4); var u = Math.min; var c = Math.max; var f = Math.sin; var d = Math.cos; var v = 2 * Math.PI; var g = l.create(); var p = l.create(); var m = l.create(); var x = []; var y = []; e.fromPoints = n, e.fromLine = i, e.fromCubic = a, e.fromQuadratic = o, e.fromArc = s }, function (t, e, r) { function n (t, e) { return Math.abs(t - e) < b } function i () { const t = M[0]; M[0] = M[1], M[1] = t } function a (t, e, r, n, a, o, s, l, h, u) { if (u > e && u > n && u > o && u > l || u < e && u < n && u < o && u < l) return 0; const c = x.cubicRootAt(e, n, o, l, u, S); if (c === 0) return 0; for (var f, d, v = 0, g = -1, p = 0; p < c; p++) { const m = S[p]; const y = m === 0 || m === 1 ? 0.5 : 1; x.cubicAt(t, r, a, s, m) < h || (g < 0 && (g = x.cubicExtrema(e, n, o, l, M), M[1] < M[0] && g > 1 && i(), f = x.cubicAt(e, n, o, l, M[0]), g > 1 && (d = x.cubicAt(e, n, o, l, M[1]))), g == 2 ? m < M[0] ? v += f < e ? y : -y : m < M[1] ? v += d < f ? y : -y : v += l < d ? y : -y : m < M[0] ? v += f < e ? y : -y : v += l < f ? y : -y) } return v } function o (t, e, r, n, i, a, o, s) { if (s > e && s > n && s > a || s < e && s < n && s < a) return 0; const l = x.quadraticRootAt(e, n, a, s, S); if (l === 0) return 0; const h = x.quadraticExtremum(e, n, a); if (h >= 0 && h <= 1) { for (var u = 0, c = x.quadraticAt(e, n, a, h), f = 0; f < l; f++) { var d = S[f] === 0 || S[f] === 1 ? 0.5 : 1; var v = x.quadraticAt(t, r, i, S[f]); v < o || (S[f] < h ? u += c < e ? d : -d : u += a < c ? d : -d) } return u } var d = S[0] === 0 || S[0] === 1 ? 0.5 : 1; var v = x.quadraticAt(t, r, i, S[0]); return v < o ? 0 : a < e ? d : -d } function s (t, e, r, n, i, a, o, s) { if ((s -= e) > r || s < -r) return 0; var l = Math.sqrt(r * r - s * s); S[0] = -l, S[1] = l; const h = Math.abs(n - i); if (h < 1e-4) return 0; if (h % _ < 1e-4) { n = 0, i = _; var u = a ? 1 : -1; return o >= S[0] + t && o <= S[1] + t ? u : 0 } if (a) { var l = n; n = m(i), i = m(l) } else n = m(n), i = m(i); n > i && (i += _); for (var c = 0, f = 0; f < 2; f++) { const d = S[f]; if (d + t > o) { let v = Math.atan2(s, d); var u = a ? 1 : -1; v < 0 && (v = _ + v), (v >= n && v <= i || v + _ >= n && v + _ <= i) && (v > Math.PI / 2 && v < 1.5 * Math.PI && (u = -u), c += u) } } return c } function l (t, e, r, i, l) { for (var h = 0, u = 0, c = 0, p = 0, m = 0, x = 0; x < t.length;) { const _ = t[x++]; switch (_ === w.M && x > 1 && (r || (h += y(u, c, p, m, i, l))), x == 1 && (u = t[x], c = t[x + 1], p = u, m = c), _) { case w.M:p = t[x++], m = t[x++], u = p, c = m; break; case w.L:if (r) { if (f.containStroke(u, c, t[x], t[x + 1], e, i, l)) return !0 } else h += y(u, c, t[x], t[x + 1], i, l) || 0; u = t[x++], c = t[x++]; break; case w.C:if (r) { if (d.containStroke(u, c, t[x++], t[x++], t[x++], t[x++], t[x], t[x + 1], e, i, l)) return !0 } else h += a(u, c, t[x++], t[x++], t[x++], t[x++], t[x], t[x + 1], i, l) || 0; u = t[x++], c = t[x++]; break; case w.Q:if (r) { if (v.containStroke(u, c, t[x++], t[x++], t[x], t[x + 1], e, i, l)) return !0 } else h += o(u, c, t[x++], t[x++], t[x], t[x + 1], i, l) || 0; u = t[x++], c = t[x++]; break; case w.A:var b = t[x++]; var S = t[x++]; var M = t[x++]; var T = t[x++]; var k = t[x++]; var C = t[x++]; var P = (t[x++], 1 - t[x++]); var I = Math.cos(k) * M + b; var A = Math.sin(k) * T + S; x > 1 ? h += y(u, c, I, A, i, l) : (p = I, m = A); var O = (i - b) * T / M + b; if (r) { if (g.containStroke(b, S, T, k, k + C, P, e, O, l)) return !0 } else h += s(b, S, T, k, k + C, P, O, l); u = Math.cos(k + C) * M + b, c = Math.sin(k + C) * T + S; break; case w.R:p = u = t[x++], m = c = t[x++]; var D = t[x++]; var L = t[x++]; var I = p + D; var A = m + L; if (r) { if (f.containStroke(p, m, I, m, e, i, l) || f.containStroke(I, m, I, A, e, i, l) || f.containStroke(I, A, p, A, e, i, l) || f.containStroke(p, A, p, m, e, i, l)) return !0 } else h += y(I, m, I, A, i, l), h += y(p, A, p, m, i, l); break; case w.Z:if (r) { if (f.containStroke(u, c, p, m, e, i, l)) return !0 } else h += y(u, c, p, m, i, l); u = p, c = m } } return r || n(c, m) || (h += y(u, c, p, m, i, l) || 0), h !== 0 } function h (t, e, r) { return l(t, 0, !1, e, r) } function u (t, e, r, n) { return l(t, e, !0, r, n) } const c = r(6); var f = r(51); var d = r(52); var v = r(53); var g = r(54); const p = r(22); var m = p.normalizeRadian; var x = r(4); var y = r(55); var w = c.CMD; var _ = 2 * Math.PI; var b = 1e-4; var S = [-1, -1, -1]; var M = [-1, -1]; e.contain = h, e.containStroke = u }, function (t, e) { function r (t, e, r, n, i, a, o) { if (i === 0) return !1; const s = i; let l = 0; let h = t; if (o > e + s && o > n + s || o < e - s && o < n - s || a > t + s && a > r + s || a < t - s && a < r - s) return !1; if (t === r) return Math.abs(a - t) <= s / 2; l = (e - n) / (t - r), h = (t * n - r * e) / (t - r); const u = l * a - o + h; return u * u / (l * l + 1) <= s / 2 * s / 2 }e.containStroke = r }, function (t, e, r) { function n (t, e, r, n, a, o, s, l, h, u, c) { if (h === 0) return !1; const f = h; return !(c > e + f && c > n + f && c > o + f && c > l + f || c < e - f && c < n - f && c < o - f && c < l - f || u > t + f && u > r + f && u > a + f && u > s + f || u < t - f && u < r - f && u < a - f && u < s - f) && i.cubicProjectPoint(t, e, r, n, a, o, s, l, u, c, null) <= f / 2 } var i = r(4); e.containStroke = n }, function (t, e, r) { function n (t, e, r, n, i, o, s, l, h) { if (s === 0) return !1; const u = s; return !(h > e + u && h > n + u && h > o + u || h < e - u && h < n - u && h < o - u || l > t + u && l > r + u && l > i + u || l < t - u && l < r - u && l < i - u) && a(t, e, r, n, i, o, l, h, null) <= u / 2 } const i = r(4); var a = i.quadraticProjectPoint; e.containStroke = n }, function (t, e, r) { function n (t, e, r, n, i, s, l, h, u) { if (l === 0) return !1; const c = l; h -= t, u -= e; const f = Math.sqrt(h * h + u * u); if (f - c > r || f + c < r) return !1; if (Math.abs(n - i) % o < 1e-4) return !0; if (s) { const d = n; n = a(i), i = a(d) } else n = a(n), i = a(i); n > i && (i += o); let v = Math.atan2(u, h); return v < 0 && (v += o), v >= n && v <= i || v + o >= n && v + o <= i } const i = r(22); var a = i.normalizeRadian; var o = 2 * Math.PI; e.containStroke = n }, function (t, e) { function r (t, e, r, n, i, a) { if (a > e && a > n || a < e && a < n) return 0; if (n === e) return 0; let o = n < e ? 1 : -1; const s = (a - e) / (n - e); return s !== 1 && s !== 0 || (o = n < e ? 0.5 : -0.5), s * (r - t) + t > i ? o : 0 }t.exports = r }, function (t, e) { const r = function (t, e) { this.image = t, this.repeat = e, this.type = 'pattern' }; r.prototype.getCanvasPattern = function (t) { return t.createPattern(this.image, this.repeat || 'repeat') }; const n = r; t.exports = n }, function (t, e, r) { function n (t, e) { let r; let n; let i; let a; let c; var f; const d = t.data; const v = s.M; const g = s.C; const p = s.L; const m = s.R; const x = s.A; const y = s.Q; for (i = 0, a = 0; i < d.length;) { switch (r = d[i++], a = i, n = 0, r) { case v:case p:n = 1; break; case g:n = 3; break; case y:n = 2; break; case x:var w = e[4]; var _ = e[5]; var b = h(e[0] * e[0] + e[1] * e[1]); var S = h(e[2] * e[2] + e[3] * e[3]); var M = u(-e[1] / S, e[0] / b); d[i] *= b, d[i++] += w, d[i] *= S, d[i++] += _, d[i++] *= b, d[i++] *= S, d[i++] += M, d[i++] += M, i += 2, a = i; break; case m:f[0] = d[i++], f[1] = d[i++], o(f, f, e), d[a++] = f[0], d[a++] = f[1], f[0] += d[i++], f[1] += d[i++], o(f, f, e), d[a++] = f[0], d[a++] = f[1] } for (c = 0; c < n; c++) { var f = l[c]; f[0] = d[i++], f[1] = d[i++], o(f, f, e), d[a++] = f[0], d[a++] = f[1] } } } const i = r(6); const a = r(2); var o = a.applyTransform; var s = i.CMD; var l = [[], [], []]; var h = Math.sqrt; var u = Math.atan2; t.exports = n }, function (t, e, r) { function n (t) { i.call(this, t) } var i = r(12); const a = r(3); const o = r(0); const s = r(10); n.prototype = { constructor: n, type: 'image', brush: function (t, e) { const r = this.style; const n = r.image; r.bind(t, this, e); const i = this._image = s.createOrUpdateImage(n, this._image, this, this.onload); if (i && s.isImageReady(i)) { const a = r.x || 0; const o = r.y || 0; let l = r.width; let h = r.height; const u = i.width / i.height; if (l == null && h != null ? l = h * u : h == null && l != null ? h = l / u : l == null && h == null && (l = i.width, h = i.height), this.setTransform(t), r.sWidth && r.sHeight) { var c = r.sx || 0; var f = r.sy || 0; t.drawImage(i, c, f, r.sWidth, r.sHeight, a, o, l, h) } else if (r.sx && r.sy) { var c = r.sx; var f = r.sy; const d = l - c; const v = h - f; t.drawImage(i, c, f, d, v, a, o, l, h) } else t.drawImage(i, a, o, l, h); this.restoreTransform(t), r.text != null && this.drawRectText(t, this.getBoundingRect()) } }, getBoundingRect: function () { const t = this.style; return this._rect || (this._rect = new a(t.x || 0, t.y || 0, t.width || 0, t.height || 0)), this._rect } }, o.inherits(n, i); const l = n; t.exports = l }, function (t, e, r) { const n = r(0); const i = r(16); const a = r(3); const o = function (t) { t = t || {}, i.call(this, t); for (const e in t)t.hasOwnProperty(e) && (this[e] = t[e]); this._children = [], this.__storage = null, this.__dirty = !0 }; o.prototype = { constructor: o, isGroup: !0, type: 'group', silent: !1, children: function () { return this._children.slice() }, childAt: function (t) { return this._children[t] }, childOfName: function (t) { for (let e = this._children, r = 0; r < e.length; r++) if (e[r].name === t) return e[r] }, childCount: function () { return this._children.length }, add: function (t) { return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this }, addBefore: function (t, e) { if (t && t !== this && t.parent !== this && e && e.parent === this) { const r = this._children; const n = r.indexOf(e); n >= 0 && (r.splice(n, 0, t), this._doAdd(t)) } return this }, _doAdd: function (t) { t.parent && t.parent.remove(t), t.parent = this; const e = this.__storage; const r = this.__zr; e && e !== t.__storage && (e.addToStorage(t), t instanceof o && t.addChildrenToStorage(e)), r && r.refresh() }, remove: function (t) { const e = this.__zr; const r = this.__storage; const i = this._children; const a = n.indexOf(i, t); return a < 0 ? this : (i.splice(a, 1), t.parent = null, r && (r.delFromStorage(t), t instanceof o && t.delChildrenFromStorage(r)), e && e.refresh(), this) }, removeAll: function () { let t; let e; const r = this._children; const n = this.__storage; for (e = 0; e < r.length; e++)t = r[e], n && (n.delFromStorage(t), t instanceof o && t.delChildrenFromStorage(n)), t.parent = null; return r.length = 0, this }, eachChild: function (t, e) { for (let r = this._children, n = 0; n < r.length; n++) { const i = r[n]; t.call(e, i, n) } return this }, traverse: function (t, e) { for (let r = 0; r < this._children.length; r++) { const n = this._children[r]; t.call(e, n), n.type === 'group' && n.traverse(t, e) } return this }, addChildrenToStorage: function (t) { for (let e = 0; e < this._children.length; e++) { const r = this._children[e]; t.addToStorage(r), r instanceof o && r.addChildrenToStorage(t) } }, delChildrenFromStorage: function (t) { for (let e = 0; e < this._children.length; e++) { const r = this._children[e]; t.delFromStorage(r), r instanceof o && r.delChildrenFromStorage(t) } }, dirty: function () { return this.__dirty = !0, this.__zr && this.__zr.refresh(), this }, getBoundingRect: function (t) { for (var e = null, r = new a(0, 0, 0, 0), n = t || this._children, i = [], o = 0; o < n.length; o++) { const s = n[o]; if (!s.ignore && !s.invisible) { const l = s.getBoundingRect(); const h = s.getLocalTransform(i); h ? (r.copy(l), r.applyTransform(h), e = e || r.clone(), e.union(r)) : (e = e || l.clone(), e.union(l)) } } return e || r } }, n.inherits(o, i); const s = o; t.exports = s }, function (t, e, r) { const n = r(12); const i = r(0); const a = r(5); const o = r(20); const s = function (t) { n.call(this, t) }; s.prototype = { constructor: s, type: 'text', brush: function (t, e) { const r = this.style; this.__dirty && o.normalizeTextStyle(r, !0), r.fill = r.stroke = r.shadowBlur = r.shadowColor = r.shadowOffsetX = r.shadowOffsetY = null; let n = r.text; n != null && (n += ''), r.bind(t, this, e), o.needDrawText(n, r) && (this.setTransform(t), o.renderText(this, t, n, r), this.restoreTransform(t)) }, getBoundingRect: function () { const t = this.style; if (this.__dirty && o.normalizeTextStyle(t, !0), !this._rect) { let e = t.text; e != null ? e += '' : e = ''; const r = a.getBoundingRect(t.text + '', t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.rich); if (r.x += t.x || 0, r.y += t.y || 0, o.getStroke(t.textStroke, t.textStrokeWidth)) { const n = t.textStrokeWidth; r.x -= n / 2, r.y -= n / 2, r.width += n, r.height += n } this._rect = r } return this._rect } }, i.inherits(s, n); const l = s; t.exports = l }, function (t, e, r) { const n = r(1); const i = n.extend({ type: 'circle', shape: { cx: 0, cy: 0, r: 0 }, buildPath: function (t, e, r) { r && t.moveTo(e.cx + e.r, e.cy), t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0) } }); t.exports = i }, function (t, e, r) { const n = r(1); const i = r(63); const a = n.extend({ type: 'sector', shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, brush: i(n.prototype.brush), buildPath: function (t, e) { const r = e.cx; const n = e.cy; const i = Math.max(e.r0 || 0, 0); const a = Math.max(e.r, 0); const o = e.startAngle; const s = e.endAngle; const l = e.clockwise; const h = Math.cos(o); const u = Math.sin(o); t.moveTo(h * i + r, u * i + n), t.lineTo(h * a + r, u * a + n), t.arc(r, n, a, o, s, !l), t.lineTo(Math.cos(s) * i + r, Math.sin(s) * i + n), i !== 0 && t.arc(r, n, i, s, o, l), t.closePath() } }); t.exports = a }, function (t, e, r) { function n (t) { return i.browser.ie && i.browser.version >= 11 ? function () { let e; const r = this.__clipPaths; const n = this.style; if (r) for (let i = 0; i < r.length; i++) { const o = r[i]; const s = o && o.shape; const l = o && o.type; if (s && (l === 'sector' && s.startAngle === s.endAngle || l === 'rect' && (!s.width || !s.height))) { for (var h = 0; h < a.length; h++)a[h][2] = n[a[h][0]], n[a[h][0]] = a[h][1]; e = !0; break } } if (t.apply(this, arguments), e) for (var h = 0; h < a.length; h++)n[a[h][0]] = a[h][2] } : t } var i = r(15); var a = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]]; t.exports = n }, function (t, e, r) { const n = r(1); const i = n.extend({ type: 'ring', shape: { cx: 0, cy: 0, r: 0, r0: 0 }, buildPath: function (t, e) { const r = e.cx; const n = e.cy; const i = 2 * Math.PI; t.moveTo(r + e.r, n), t.arc(r, n, e.r, 0, i, !1), t.moveTo(r + e.r0, n), t.arc(r, n, e.r0, 0, i, !0) } }); t.exports = i }, function (t, e, r) { const n = r(1); const i = r(23); const a = n.extend({ type: 'polygon', shape: { points: null, smooth: !1, smoothConstraint: null }, buildPath: function (t, e) { i.buildPath(t, e, !0) } }); t.exports = a }, function (t, e, r) { function n (t, e, r, n, i, a, o) { const s = 0.5 * (r - t); const l = 0.5 * (n - e); return (2 * (e - r) + s + l) * o + (-3 * (e - r) - 2 * s - l) * a + s * i + e } function i (t, e) { for (var r = t.length, i = [], a = 0, s = 1; s < r; s++)a += o(t[s - 1], t[s]); let l = a / 2; l = l < r ? r : l; for (var s = 0; s < l; s++) { var h; var u; var c; const f = s / (l - 1) * (e ? r : r - 1); const d = Math.floor(f); const v = f - d; const g = t[d % r]; e ? (h = t[(d - 1 + r) % r], u = t[(d + 1) % r], c = t[(d + 2) % r]) : (h = t[d === 0 ? d : d - 1], u = t[d > r - 2 ? r - 1 : d + 1], c = t[d > r - 3 ? r - 1 : d + 2]); const p = v * v; const m = v * p; i.push([n(h[0], g[0], u[0], c[0], v, p, m), n(h[1], g[1], u[1], c[1], v, p, m)]) } return i } const a = r(2); var o = a.distance; t.exports = i }, function (t, e, r) { function n (t, e, r, n) { let i; let f; let d; let v; const g = []; const p = []; const m = []; const x = []; if (n) { d = [1 / 0, 1 / 0], v = [-1 / 0, -1 / 0]; for (var y = 0, w = t.length; y < w; y++)a(d, d, t[y]), o(v, v, t[y]); a(d, d, n[0]), o(v, v, n[1]) } for (var y = 0, w = t.length; y < w; y++) { const _ = t[y]; if (r)i = t[y ? y - 1 : w - 1], f = t[(y + 1) % w]; else { if (y === 0 || y === w - 1) { g.push(u(t[y])); continue }i = t[y - 1], f = t[y + 1] }c(p, f, i), s(p, p, e); let b = l(_, i); let S = l(_, f); const M = b + S; M !== 0 && (b /= M, S /= M), s(m, p, -b), s(x, p, S); const T = h([], _, m); const k = h([], _, x); n && (o(T, T, d), a(T, T, v), o(k, k, d), a(k, k, v)), g.push(T), g.push(k) } return r && g.push(g.shift()), g } const i = r(2); var a = i.min; var o = i.max; var s = i.scale; var l = i.distance; var h = i.add; var u = i.clone; var c = i.sub; t.exports = n }, function (t, e, r) { const n = r(1); const i = r(23); const a = n.extend({ type: 'polyline', shape: { points: null, smooth: !1, smoothConstraint: null }, style: { stroke: '#000', fill: null }, buildPath: function (t, e) { i.buildPath(t, e, !1) } }); t.exports = a }, function (t, e, r) { const n = r(1); const i = r(21); const a = n.extend({ type: 'rect', shape: { r: 0, x: 0, y: 0, width: 0, height: 0 }, buildPath: function (t, e) { const r = e.x; const n = e.y; const a = e.width; const o = e.height; e.r ? i.buildPath(t, e) : t.rect(r, n, a, o), t.closePath() } }); t.exports = a }, function (t, e, r) { const n = r(1); const i = n.extend({ type: 'line', shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1 }, style: { stroke: '#000', fill: null }, buildPath: function (t, e) { const r = e.x1; const n = e.y1; let i = e.x2; let a = e.y2; const o = e.percent; o !== 0 && (t.moveTo(r, n), o < 1 && (i = r * (1 - o) + i * o, a = n * (1 - o) + a * o), t.lineTo(i, a)) }, pointAt: function (t) { const e = this.shape; return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t] } }); t.exports = i }, function (t, e, r) { function n (t, e, r) { const n = t.cpx2; const i = t.cpy2; return n === null || i === null ? [(r ? f : u)(t.x1, t.cpx1, t.cpx2, t.x2, e), (r ? f : u)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(r ? c : h)(t.x1, t.cpx1, t.x2, e), (r ? c : h)(t.y1, t.cpy1, t.y2, e)] } const i = r(1); const a = r(2); const o = r(4); const s = o.quadraticSubdivide; const l = o.cubicSubdivide; var h = o.quadraticAt; var u = o.cubicAt; var c = o.quadraticDerivativeAt; var f = o.cubicDerivativeAt; const d = []; const v = i.extend({ type: 'bezier-curve', shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, percent: 1 }, style: { stroke: '#000', fill: null }, buildPath: function (t, e) { const r = e.x1; const n = e.y1; let i = e.x2; let a = e.y2; let o = e.cpx1; let h = e.cpy1; let u = e.cpx2; let c = e.cpy2; const f = e.percent; f !== 0 && (t.moveTo(r, n), u == null || c == null ? (f < 1 && (s(r, o, i, f, d), o = d[1], i = d[2], s(n, h, a, f, d), h = d[1], a = d[2]), t.quadraticCurveTo(o, h, i, a)) : (f < 1 && (l(r, o, u, i, f, d), o = d[1], u = d[2], i = d[3], l(n, h, c, a, f, d), h = d[1], c = d[2], a = d[3]), t.bezierCurveTo(o, h, u, c, i, a))) }, pointAt: function (t) { return n(this.shape, t, !1) }, tangentAt: function (t) { const e = n(this.shape, t, !0); return a.normalize(e, e) } }); t.exports = v }, function (t, e, r) { const n = r(1); const i = n.extend({ type: 'arc', shape: { cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: 2 * Math.PI, clockwise: !0 }, style: { stroke: '#000', fill: null }, buildPath: function (t, e) { const r = e.cx; const n = e.cy; const i = Math.max(e.r, 0); const a = e.startAngle; const o = e.endAngle; const s = e.clockwise; const l = Math.cos(a); const h = Math.sin(a); t.moveTo(l * i + r, h * i + n), t.arc(r, n, i, a, o, !s) } }); t.exports = i }, function (t, e, r) { const n = r(1); const i = n.extend({ type: 'compound', shape: { paths: null }, _updatePathDirty: function () { for (var t = this.__dirtyPath, e = this.shape.paths, r = 0; r < e.length; r++)t = t || e[r].__dirtyPath; this.__dirtyPath = t, this.__dirty = this.__dirty || t }, beforeBrush: function () { this._updatePathDirty(); for (let t = this.shape.paths || [], e = this.getGlobalScale(), r = 0; r < t.length; r++)t[r].path || t[r].createPathProxy(), t[r].path.setScale(e[0], e[1]) }, buildPath: function (t, e) { for (let r = e.paths || [], n = 0; n < r.length; n++)r[n].buildPath(t, r[n].shape, !0) }, afterBrush: function () { for (let t = this.shape.paths || [], e = 0; e < t.length; e++)t[e].__dirtyPath = !1 }, getBoundingRect: function () { return this._updatePathDirty(), n.prototype.getBoundingRect.call(this) } }); t.exports = i }, function (t, e, r) { const n = r(0); const i = r(24); const a = function (t, e, r, n, a, o) { this.x = t == null ? 0 : t, this.y = e == null ? 0 : e, this.x2 = r == null ? 1 : r, this.y2 = n == null ? 0 : n, this.type = 'linear', this.global = o || !1, i.call(this, a) }; a.prototype = { constructor: a }, n.inherits(a, i); const o = a; t.exports = o }, function (t, e, r) { const n = r(0); const i = r(24); const a = function (t, e, r, n, a) { this.x = t == null ? 0.5 : t, this.y = e == null ? 0.5 : e, this.r = r == null ? 0.5 : r, this.type = 'radial', this.global = a || !1, i.call(this, n) }; a.prototype = { constructor: a }, n.inherits(a, i); const o = a; t.exports = o }, function (t, e, r) { const n = r(11); const i = n([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign']]); const a = { getItemStyle: function (t, e) { const r = i(this, t, e); const n = this.getBorderLineDash(); return n && (r.lineDash = n), r }, getBorderLineDash: function () { const t = this.get('borderType'); return t === 'solid' || t == null ? null : t === 'dashed' ? [5, 5] : [1, 1] } }; t.exports = a }, function (t, e, r) { const n = r(7); n.extendChartView({ type: 'wordCloud', render: function (t, e, r) { const i = this.group; i.removeAll(); const a = t.getData(); const o = t.get('gridSize'); t.layoutInstance.ondraw = function (t, e, r, s) { const l = a.getItemModel(r); const h = l.getModel('textStyle.normal'); const u = l.getModel('textStyle.emphasis'); const c = new n.graphic.Text({ style: n.graphic.setTextStyle({}, h, { x: s.info.fillTextOffsetX, y: s.info.fillTextOffsetY + 0.5 * e, text: t, textBaseline: 'middle', textFill: a.getItemVisual(r, 'color'), fontSize: e }), scale: [1 / s.info.mu, 1 / s.info.mu], position: [(s.gx + s.info.gw / 2) * o, (s.gy + s.info.gh / 2) * o], rotation: s.rot }); i.add(c), a.setItemGraphicEl(r, c), n.graphic.setHoverStyle(c, n.graphic.setTextStyle({}, u, null, { forMerge: !0 }, !0)) }, this._model = t }, remove: function () { this.group.removeAll(), this._model.layoutInstance.dispose() }, dispose: function () { this._model.layoutInstance.dispose() } }) }, function (t, e, r) {
 'use strict'; let n, i/*!
 * wordcloud2.js
 * http://timdream.org/wordcloud2.js/
 *
 * Copyright 2011 - 2013 Tim Chien
 * Released under the MIT license
 */
window.setImmediate || (window.setImmediate = (function () { return window.msSetImmediate || window.webkitSetImmediate || window.mozSetImmediate || window.oSetImmediate || (function () { if (!window.postMessage || !window.addEventListener) return null; const t = [void 0]; const e = 'zero-timeout-message'; const r = function (r) { const n = t.length; return t.push(r), window.postMessage(e + n.toString(36), '*'), n }; return window.addEventListener('message', function (r) { if (typeof r.data === 'string' && r.data.substr(0, e.length) === e) { r.stopImmediatePropagation(); const n = parseInt(r.data.substr(e.length), 36); t[n] && (t[n](), t[n] = void 0) } }, !0), window.clearImmediate = function (e) { t[e] && (t[e] = void 0) }, r }()) || function (t) { window.setTimeout(t, 0) } }())), window.clearImmediate || (window.clearImmediate = (function () { return window.msClearImmediate || window.webkitClearImmediate || window.mozClearImmediate || window.oClearImmediate || function (t) { window.clearTimeout(t) } }())), (function (r) { const a = (function () { const t = document.createElement('canvas'); if (!t || !t.getContext) return !1; const e = t.getContext('2d'); return !!e.getImageData && (!!e.fillText && (!!Array.prototype.some && !!Array.prototype.push)) }()); const o = (function () { if (a) { for (var t, e, r = document.createElement('canvas').getContext('2d'), n = 20; n;) { if (r.font = n.toString(10) + 'px sans-serif', r.measureText('Ｗ').width === t && r.measureText('m').width === e) return n + 1; t = r.measureText('Ｗ').width, e = r.measureText('m').width, n-- } return 0 } }()); const s = function (t) { for (var e, r, n = t.length; n; e = Math.floor(Math.random() * n), r = t[--n], t[n] = t[e], t[e] = r);return t }; const l = function (t, e) { function r (t, e) { return 'hsl(' + (360 * Math.random()).toFixed() + ',' + (30 * Math.random() + 70).toFixed() + '%,' + (Math.random() * (e - t) + t).toFixed() + '%)' } if (a) { Array.isArray(t) || (t = [t]), t.forEach(function (e, r) { if (typeof e === 'string') { if (t[r] = document.getElementById(e), !t[r]) throw 'The element id specified is not found.' } else if (!e.tagName && !e.appendChild) throw 'You must pass valid HTML elements, or ID of the element.' }); const n = { list: [], fontFamily: '"Trebuchet MS", "Heiti TC", "微軟正黑體", "Arial Unicode MS", "Droid Fallback Sans", sans-serif', fontWeight: 'normal', color: 'random-dark', minSize: 0, weightFactor: 1, clearCanvas: !0, backgroundColor: '#fff', gridSize: 8, drawOutOfBound: !1, origin: null, drawMask: !1, maskColor: 'rgba(255,0,0,0.3)', maskGapWidth: 0.3, wait: 0, abortThreshold: 0, abort: function () {}, minRotation: -Math.PI / 2, maxRotation: Math.PI / 2, rotationStep: 0.1, shuffle: !0, rotateRatio: 0.1, shape: 'circle', ellipticity: 0.65, classes: null, hover: null, click: null }; if (e) for (const i in e)i in n && (n[i] = e[i]); if (typeof n.weightFactor !== 'function') { const l = n.weightFactor; n.weightFactor = function (t) { return t * l } } if (typeof n.shape !== 'function') switch (n.shape) { case 'circle':default:n.shape = 'circle'; break; case 'cardioid':n.shape = function (t) { return 1 - Math.sin(t) }; break; case 'diamond':case 'square':n.shape = function (t) { const e = t % (2 * Math.PI / 4); return 1 / (Math.cos(e) + Math.sin(e)) }; break; case 'triangle-forward':n.shape = function (t) { const e = t % (2 * Math.PI / 3); return 1 / (Math.cos(e) + Math.sqrt(3) * Math.sin(e)) }; break; case 'triangle':case 'triangle-upright':n.shape = function (t) { const e = (t + 3 * Math.PI / 2) % (2 * Math.PI / 3); return 1 / (Math.cos(e) + Math.sqrt(3) * Math.sin(e)) }; break; case 'pentagon':n.shape = function (t) { const e = (t + 0.955) % (2 * Math.PI / 5); return 1 / (Math.cos(e) + 0.726543 * Math.sin(e)) }; break; case 'star':n.shape = function (t) { const e = (t + 0.955) % (2 * Math.PI / 10); return (t + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0 ? 1 / (Math.cos(2 * Math.PI / 10 - e) + 3.07768 * Math.sin(2 * Math.PI / 10 - e)) : 1 / (Math.cos(e) + 3.07768 * Math.sin(e)) } }n.gridSize = Math.max(Math.floor(n.gridSize), 4); let h; let u; let c; let f; let d; let v; let g; const p = n.gridSize; const m = p - n.maskGapWidth; const x = Math.abs(n.maxRotation - n.minRotation); const y = Math.min(n.maxRotation, n.minRotation); const w = n.rotationStep; switch (n.color) { case 'random-dark':g = function () { return r(10, 50) }; break; case 'random-light':g = function () { return r(50, 90) }; break; default:typeof n.color === 'function' && (g = n.color) } let _ = null; typeof n.classes === 'function' && (_ = n.classes); let b; let S = !1; const M = []; const T = function (t) { let e; let r; const n = t.currentTarget; const i = n.getBoundingClientRect(); t.touches ? (e = t.touches[0].clientX, r = t.touches[0].clientY) : (e = t.clientX, r = t.clientY); const a = e - i.left; const o = r - i.top; const s = Math.floor(a * (n.width / i.width || 1) / p); const l = Math.floor(o * (n.height / i.height || 1) / p); return M[s][l] }; const k = function (t) { const e = T(t); if (b !== e) { if (b = e, !e) return void n.hover(void 0, void 0, t); n.hover(e.item, e.dimension, t) } }; const C = function (t) { const e = T(t); e && (n.click(e.item, e.dimension, t), t.preventDefault()) }; const P = []; const I = function (t) { if (P[t]) return P[t]; const e = 8 * t; let r = e; const i = []; for (t === 0 && i.push([f[0], f[1], 0]); r--;) { let a = 1; n.shape !== 'circle' && (a = n.shape(r / e * 2 * Math.PI)), i.push([f[0] + t * a * Math.cos(-r / e * 2 * Math.PI), f[1] + t * a * Math.sin(-r / e * 2 * Math.PI) * n.ellipticity, r / e * 2 * Math.PI]) } return P[t] = i, i }; const A = function () { return n.abortThreshold > 0 && (new Date()).getTime() - v > n.abortThreshold }; const O = function () { return n.rotateRatio === 0 ? 0 : Math.random() > n.rotateRatio ? 0 : x === 0 ? y : y + Math.round(Math.random() * x / w) * w }; const D = function (t, e, r) { const i = n.weightFactor(e); if (i <= n.minSize) return !1; let a = 1; i < o && (a = (function () { for (var t = 2; t * i < o;)t += 2; return t }())); const s = document.createElement('canvas'); const l = s.getContext('2d', { willReadFrequently: !0 }); l.font = n.fontWeight + ' ' + (i * a).toString(10) + 'px ' + n.fontFamily; const h = l.measureText(t).width / a; const u = Math.max(i * a, l.measureText('m').width, l.measureText('Ｗ').width) / a; let c = h + 2 * u; let f = 3 * u; const d = Math.ceil(c / p); const v = Math.ceil(f / p); c = d * p, f = v * p; const g = -h / 2; const m = 0.4 * -u; const x = Math.ceil((c * Math.abs(Math.sin(r)) + f * Math.abs(Math.cos(r))) / p); const y = Math.ceil((c * Math.abs(Math.cos(r)) + f * Math.abs(Math.sin(r))) / p); const w = y * p; const _ = x * p; s.setAttribute('width', w), s.setAttribute('height', _), l.scale(1 / a, 1 / a), l.translate(w * a / 2, _ * a / 2), l.rotate(-r), l.font = n.fontWeight + ' ' + (i * a).toString(10) + 'px ' + n.fontFamily, l.fillStyle = '#000', l.textBaseline = 'middle', l.fillText(t, g * a, (m + 0.5 * i) * a); const b = l.getImageData(0, 0, w, _).data; if (A()) return !1; for (var S, M, T, k = [], C = y, P = [x / 2, y / 2, x / 2, y / 2]; C--;) for (S = x; S--;) { T = p; t:for (;T--;) for (M = p; M--;) if (b[4 * ((S * p + T) * w + (C * p + M)) + 3]) { k.push([C, S]), C < P[3] && (P[3] = C), C > P[1] && (P[1] = C), S < P[0] && (P[0] = S), S > P[2] && (P[2] = S); break t } } return { mu: a, occupied: k, bounds: P, gw: y, gh: x, fillTextOffsetX: g, fillTextOffsetY: m, fillTextWidth: h, fillTextHeight: u, fontSize: i } }; const L = function (t, e, r, i, a) { for (let o = a.length; o--;) { const s = t + a[o][0]; const l = e + a[o][1]; if (s >= u || l >= c || s < 0 || l < 0) { if (!n.drawOutOfBound) return !1 } else if (!h[s][l]) return !1 } return !0 }; const F = function (e, r, i, a, o, s, l, h, u) { let c; const f = i.fontSize; c = g ? g(a, o, f, s, l) : n.color; let d; d = _ ? _(a, o, f, s, l) : n.classes; const v = i.bounds; v[3], v[0], v[1], v[3], v[2], v[0], t.forEach(function (t) { if (t.getContext) { const o = t.getContext('2d'); const s = i.mu; o.save(), o.scale(1 / s, 1 / s), o.font = n.fontWeight + ' ' + (f * s).toString(10) + 'px ' + n.fontFamily, o.fillStyle = c, o.translate((e + i.gw / 2) * p * s, (r + i.gh / 2) * p * s), h !== 0 && o.rotate(-h), o.textBaseline = 'middle', o.fillText(a, i.fillTextOffsetX * s, (i.fillTextOffsetY + 0.5 * f) * s), o.restore() } else { const l = document.createElement('span'); let v = ''; v = 'rotate(' + -h / Math.PI * 180 + 'deg) ', i.mu !== 1 && (v += 'translateX(-' + i.fillTextWidth / 4 + 'px) scale(' + 1 / i.mu + ')'); const g = { position: 'absolute', display: 'block', font: n.fontWeight + ' ' + f * i.mu + 'px ' + n.fontFamily, left: (e + i.gw / 2) * p + i.fillTextOffsetX + 'px', top: (r + i.gh / 2) * p + i.fillTextOffsetY + 'px', width: i.fillTextWidth + 'px', height: i.fillTextHeight + 'px', lineHeight: f + 'px', whiteSpace: 'nowrap', transform: v, webkitTransform: v, msTransform: v, transformOrigin: '50% 40%', webkitTransformOrigin: '50% 40%', msTransformOrigin: '50% 40%' }; c && (g.color = c), l.textContent = a; for (const m in g)l.style[m] = g[m]; if (u) for (const x in u)l.setAttribute(x, u[x]); d && (l.className += d), t.appendChild(l) } }) }; const R = function (e, r, n, i, a) { if (!(e >= u || r >= c || e < 0 || r < 0)) { if (h[e][r] = !1, n) { t[0].getContext('2d').fillRect(e * p, r * p, m, m) }S && (M[e][r] = { item: a, dimension: i }) } }; const B = function (e, r, i, a, o, s) { let l; const h = o.occupied; const f = n.drawMask; f && (l = t[0].getContext('2d'), l.save(), l.fillStyle = n.maskColor); let d; if (S) { const v = o.bounds; d = { x: (e + v[3]) * p, y: (r + v[0]) * p, w: (v[1] - v[3] + 1) * p, h: (v[2] - v[0] + 1) * p } } for (let g = h.length; g--;) { const m = e + h[g][0]; const x = r + h[g][1]; m >= u || x >= c || m < 0 || x < 0 || R(m, x, f, d, s) }f && l.restore() }; const z = function (t) { let e, r, i; Array.isArray(t) ? (e = t[0], r = t[1]) : (e = t.word, r = t.weight, i = t.attributes); const a = O(); const o = D(e, r, a); if (!o) return !1; if (A()) return !1; if (!n.drawOutOfBound) { const l = o.bounds; if (l[1] - l[3] + 1 > u || l[2] - l[0] + 1 > c) return !1 } for (var h = d + 1; h--;) { let f = I(d - h); n.shuffle && (f = [].concat(f), s(f)); for (let v = 0; v < f.length; v++) { const g = (function (n) { let s = Math.floor(n[0] - o.gw / 2); let l = Math.floor(n[1] - o.gh / 2); o.gw, o.gh; return !!L(s, l, 0, 0, o.occupied) && (F(s, l, o, e, r, d - h, n[2], a, i), B(s, l, 0, 0, o, t), { gx: s, gy: l, rot: a, info: o }) }(f[v])); if (g) return g } } return null }; const N = function (e, r, n) { if (r) return !t.some(function (t) { const i = document.createEvent('CustomEvent'); return i.initCustomEvent(e, !0, r, n || {}), !t.dispatchEvent(i) }, this); t.forEach(function (t) { const i = document.createEvent('CustomEvent'); i.initCustomEvent(e, !0, r, n || {}), t.dispatchEvent(i) }, this) }; !(function () { const e = t[0]; if (e.getContext)u = Math.ceil(e.width / p), c = Math.ceil(e.height / p); else { const r = e.getBoundingClientRect(); u = Math.ceil(r.width / p), c = Math.ceil(r.height / p) } if (N('wordcloudstart', !0)) { f = n.origin ? [n.origin[0] / p, n.origin[1] / p] : [u / 2, c / 2], d = Math.floor(Math.sqrt(u * u + c * c)), h = []; let i, a, o; if (!e.getContext || n.clearCanvas) for (t.forEach(function (t) { if (t.getContext) { const e = t.getContext('2d'); e.fillStyle = n.backgroundColor, e.clearRect(0, 0, u * (p + 1), c * (p + 1)), e.fillRect(0, 0, u * (p + 1), c * (p + 1)) } else t.textContent = '', t.style.backgroundColor = n.backgroundColor, t.style.position = 'relative' }), i = u; i--;) for (h[i] = [], a = c; a--;)h[i][a] = !0; else { let s = document.createElement('canvas').getContext('2d'); s.fillStyle = n.backgroundColor, s.fillRect(0, 0, 1, 1); let l = s.getImageData(0, 0, 1, 1).data; let g = e.getContext('2d').getImageData(0, 0, u * p, c * p).data; i = u; for (var m, x; i--;) for (h[i] = [], a = c; a--;) { x = p; t:for (;x--;) for (m = p; m--;) for (o = 4; o--;) if (g[4 * ((a * p + x) * u * p + (i * p + m)) + o] !== l[o]) { h[i][a] = !1; break t }!1 !== h[i][a] && (h[i][a] = !0) }g = s = l = void 0 } if (n.hover || n.click) { for (S = !0, i = u + 1; i--;)M[i] = []; n.hover && e.addEventListener('mousemove', k), n.click && (e.addEventListener('click', C), e.addEventListener('touchstart', C), e.addEventListener('touchend', function (t) { t.preventDefault() }), e.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)'), e.addEventListener('wordcloudstart', function t () { e.removeEventListener('wordcloudstart', t), e.removeEventListener('mousemove', k), e.removeEventListener('click', C), b = void 0 }) }o = 0; let y, w; n.wait !== 0 ? (y = window.setTimeout, w = window.clearTimeout) : (y = window.setImmediate, w = window.clearImmediate); const _ = function (e, r) { t.forEach(function (t) { t.removeEventListener(e, r) }, this) }; const T = function t () { _('wordcloudstart', t), w(P) }; !(function (e, r) { t.forEach(function (t) { t.addEventListener(e, r) }, this) }('wordcloudstart', T)); var P = y(function t () { if (o >= n.list.length) return w(P), N('wordcloudstop', !1), void _('wordcloudstart', T); v = (new Date()).getTime(); const e = z(n.list[o]); const r = !N('wordclouddrawn', !0, { item: n.list[o], drawn: e }); if (A() || r) return w(P), n.abort(), N('wordcloudabort', !1), N('wordcloudstop', !1), void _('wordcloudstart', T); o++, P = y(t, n.wait) }, n.wait) } }()) } }; l.isSupported = a, l.minFontSize = o, n = [], void 0 !== (i = (function () { return l }.apply(e, n))) && (t.exports = i) }())
}]))
}))
